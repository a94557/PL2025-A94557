Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    PROCEDURE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; block .
Rule 2     block -> declarations BEGIN optional_statements END
Rule 3     optional_statements -> statements
Rule 4     optional_statements -> empty
Rule 5     declarations -> declarations declaration
Rule 6     declarations -> declaration
Rule 7     declarations -> empty
Rule 8     declaration -> VAR var_declarations
Rule 9     declaration -> function_declaration
Rule 10    var_declarations -> var_declarations var_declaration
Rule 11    var_declarations -> var_declaration
Rule 12    function_declaration -> FUNCTION ID ( param_list_opt ) : type ; function_block ;
Rule 13    function_block -> VAR var_declarations BEGIN optional_statements END
Rule 14    function_block -> BEGIN optional_statements END
Rule 15    param_list_opt -> param_list
Rule 16    param_list_opt -> empty
Rule 17    param_list -> param_list , param
Rule 18    param_list -> param
Rule 19    param -> ID : type
Rule 20    id_list -> ID
Rule 21    id_list -> id_list , ID
Rule 22    var_declaration -> id_list : type ;
Rule 23    type -> INTEGER
Rule 24    type -> BOOLEAN
Rule 25    type -> STRING_TYPE
Rule 26    type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type
Rule 27    statements -> statements statement ;
Rule 28    statements -> statements statement
Rule 29    statements -> statement ;
Rule 30    statements -> statement
Rule 31    statement -> assignment
Rule 32    statement -> if_statement
Rule 33    statement -> while_loop
Rule 34    statement -> for_loop
Rule 35    statement -> compound_statement
Rule 36    statement -> writeln
Rule 37    statement -> write
Rule 38    statement -> readln
Rule 39    statement -> empty
Rule 40    assignment -> variable ASSIGN expression
Rule 41    if_statement -> IF expression THEN statement ELSE statement
Rule 42    if_statement -> IF expression THEN statement
Rule 43    variable -> ID
Rule 44    variable -> variable LBRACKET expression RBRACKET
Rule 45    while_loop -> WHILE expression DO statement
Rule 46    for_loop -> FOR ID ASSIGN expression TO expression DO statement
Rule 47    for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement
Rule 48    compound_statement -> BEGIN statements END
Rule 49    expression -> STRING
Rule 50    writeln -> WRITELN ( expression_list )
Rule 51    write -> WRITE ( expression_list )
Rule 52    readln -> READLN ( expression_list )
Rule 53    expression -> expression + expression
Rule 54    expression -> expression - expression
Rule 55    expression -> expression * expression
Rule 56    expression -> expression / expression
Rule 57    expression -> expression DIV expression
Rule 58    expression -> expression MOD expression
Rule 59    expression -> expression AND expression
Rule 60    expression -> expression OR expression
Rule 61    expression -> expression = expression
Rule 62    expression -> expression < expression
Rule 63    expression -> expression > expression
Rule 64    expression -> expression LE expression
Rule 65    expression -> expression GE expression
Rule 66    expression -> expression NE expression
Rule 67    expression -> NOT expression
Rule 68    expression -> ( expression )
Rule 69    expression -> NUMBER
Rule 70    expression -> TRUE
Rule 71    expression -> FALSE
Rule 72    expression -> ID LBRACKET expression RBRACKET
Rule 73    expression -> variable
Rule 74    expression -> ID
Rule 75    expression_list -> expression
Rule 76    expression_list -> expression_list , expression
Rule 77    expression -> ID ( expression_list_opt )
Rule 78    expression_list_opt -> expression_list
Rule 79    expression_list_opt -> empty
Rule 80    empty -> <empty>

Terminals, with rules where they appear

(                    : 12 50 51 52 68 77
)                    : 12 50 51 52 68 77
*                    : 55
+                    : 53
,                    : 17 21 76
-                    : 54
.                    : 1
/                    : 56
:                    : 12 19 22
;                    : 1 12 12 22 27 29
<                    : 62
=                    : 61
>                    : 63
AND                  : 59
ARRAY                : 26
ASSIGN               : 40 46 47
BEGIN                : 2 13 14 48
BOOLEAN              : 24
DIV                  : 57
DO                   : 45 46 47
DOTDOT               : 26
DOWNTO               : 47
ELSE                 : 41
END                  : 2 13 14 48
FALSE                : 71
FOR                  : 46 47
FUNCTION             : 12
GE                   : 65
ID                   : 1 12 19 20 21 43 46 47 72 74 77
IF                   : 41 42
INTEGER              : 23
LBRACKET             : 26 44 72
LE                   : 64
MOD                  : 58
NE                   : 66
NOT                  : 67
NUMBER               : 26 26 69
OF                   : 26
OR                   : 60
PROCEDURE            : 
PROGRAM              : 1
RBRACKET             : 26 44 72
READLN               : 52
STRING               : 49
STRING_TYPE          : 25
THEN                 : 41 42
TO                   : 46
TRUE                 : 70
VAR                  : 8 13
WHILE                : 45
WRITE                : 51
WRITELN              : 50
error                : 

Nonterminals, with rules where they appear

assignment           : 31
block                : 1
compound_statement   : 35
declaration          : 5 6
declarations         : 2 5
empty                : 4 7 16 39 79
expression           : 40 41 42 44 45 46 46 47 47 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 66 67 68 72 75 76
expression_list      : 50 51 52 76 78
expression_list_opt  : 77
for_loop             : 34
function_block       : 12
function_declaration : 9
id_list              : 21 22
if_statement         : 32
optional_statements  : 2 13 14
param                : 17 18
param_list           : 15 17
param_list_opt       : 12
program              : 0
readln               : 38
statement            : 27 28 29 30 41 41 42 45 46 47
statements           : 3 27 28 48
type                 : 12 19 22 26
var_declaration      : 10 11
var_declarations     : 8 10 13
variable             : 40 44 73
while_loop           : 33
write                : 37
writeln              : 36

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; block .

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID ; block .

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . ; block .

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . block .
    (2) block -> . declarations BEGIN optional_statements END
    (5) declarations -> . declarations declaration
    (6) declarations -> . declaration
    (7) declarations -> . empty
    (8) declaration -> . VAR var_declarations
    (9) declaration -> . function_declaration
    (80) empty -> .
    (12) function_declaration -> . FUNCTION ID ( param_list_opt ) : type ; function_block ;

  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for FUNCTION resolved as shift
    VAR             shift and go to state 9
    BEGIN           reduce using rule 80 (empty -> .)
    FUNCTION        shift and go to state 11

  ! VAR             [ reduce using rule 80 (empty -> .) ]
  ! FUNCTION        [ reduce using rule 80 (empty -> .) ]

    block                          shift and go to state 5
    declarations                   shift and go to state 6
    declaration                    shift and go to state 7
    empty                          shift and go to state 8
    function_declaration           shift and go to state 10

state 5

    (1) program -> PROGRAM ID ; block . .

    .               shift and go to state 12


state 6

    (2) block -> declarations . BEGIN optional_statements END
    (5) declarations -> declarations . declaration
    (8) declaration -> . VAR var_declarations
    (9) declaration -> . function_declaration
    (12) function_declaration -> . FUNCTION ID ( param_list_opt ) : type ; function_block ;

    BEGIN           shift and go to state 13
    VAR             shift and go to state 9
    FUNCTION        shift and go to state 11

    declaration                    shift and go to state 14
    function_declaration           shift and go to state 10

state 7

    (6) declarations -> declaration .

    BEGIN           reduce using rule 6 (declarations -> declaration .)
    VAR             reduce using rule 6 (declarations -> declaration .)
    FUNCTION        reduce using rule 6 (declarations -> declaration .)


state 8

    (7) declarations -> empty .

    BEGIN           reduce using rule 7 (declarations -> empty .)
    VAR             reduce using rule 7 (declarations -> empty .)
    FUNCTION        reduce using rule 7 (declarations -> empty .)


state 9

    (8) declaration -> VAR . var_declarations
    (10) var_declarations -> . var_declarations var_declaration
    (11) var_declarations -> . var_declaration
    (22) var_declaration -> . id_list : type ;
    (20) id_list -> . ID
    (21) id_list -> . id_list , ID

    ID              shift and go to state 18

    var_declarations               shift and go to state 15
    var_declaration                shift and go to state 16
    id_list                        shift and go to state 17

state 10

    (9) declaration -> function_declaration .

    BEGIN           reduce using rule 9 (declaration -> function_declaration .)
    VAR             reduce using rule 9 (declaration -> function_declaration .)
    FUNCTION        reduce using rule 9 (declaration -> function_declaration .)


state 11

    (12) function_declaration -> FUNCTION . ID ( param_list_opt ) : type ; function_block ;

    ID              shift and go to state 19


state 12

    (1) program -> PROGRAM ID ; block . .

    $end            reduce using rule 1 (program -> PROGRAM ID ; block . .)


state 13

    (2) block -> declarations BEGIN . optional_statements END
    (3) optional_statements -> . statements
    (4) optional_statements -> . empty
    (27) statements -> . statements statement ;
    (28) statements -> . statements statement
    (29) statements -> . statement ;
    (30) statements -> . statement
    (80) empty -> .
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    END             reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    optional_statements            shift and go to state 21
    statements                     shift and go to state 22
    empty                          shift and go to state 23
    statement                      shift and go to state 24
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    variable                       shift and go to state 33

state 14

    (5) declarations -> declarations declaration .

    BEGIN           reduce using rule 5 (declarations -> declarations declaration .)
    VAR             reduce using rule 5 (declarations -> declarations declaration .)
    FUNCTION        reduce using rule 5 (declarations -> declarations declaration .)


state 15

    (8) declaration -> VAR var_declarations .
    (10) var_declarations -> var_declarations . var_declaration
    (22) var_declaration -> . id_list : type ;
    (20) id_list -> . ID
    (21) id_list -> . id_list , ID

    BEGIN           reduce using rule 8 (declaration -> VAR var_declarations .)
    VAR             reduce using rule 8 (declaration -> VAR var_declarations .)
    FUNCTION        reduce using rule 8 (declaration -> VAR var_declarations .)
    ID              shift and go to state 18

    var_declaration                shift and go to state 41
    id_list                        shift and go to state 17

state 16

    (11) var_declarations -> var_declaration .

    ID              reduce using rule 11 (var_declarations -> var_declaration .)
    BEGIN           reduce using rule 11 (var_declarations -> var_declaration .)
    VAR             reduce using rule 11 (var_declarations -> var_declaration .)
    FUNCTION        reduce using rule 11 (var_declarations -> var_declaration .)


state 17

    (22) var_declaration -> id_list . : type ;
    (21) id_list -> id_list . , ID

    :               shift and go to state 42
    ,               shift and go to state 43


state 18

    (20) id_list -> ID .

    :               reduce using rule 20 (id_list -> ID .)
    ,               reduce using rule 20 (id_list -> ID .)


state 19

    (12) function_declaration -> FUNCTION ID . ( param_list_opt ) : type ; function_block ;

    (               shift and go to state 44


state 20

    (48) compound_statement -> BEGIN . statements END
    (27) statements -> . statements statement ;
    (28) statements -> . statements statement
    (29) statements -> . statement ;
    (30) statements -> . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ;               reduce using rule 80 (empty -> .)
    END             reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    statements                     shift and go to state 45
    statement                      shift and go to state 24
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 21

    (2) block -> declarations BEGIN optional_statements . END

    END             shift and go to state 47


state 22

    (3) optional_statements -> statements .
    (27) statements -> statements . statement ;
    (28) statements -> statements . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! reduce/reduce conflict for END resolved using rule 3 (optional_statements -> statements .)
  ! shift/reduce conflict for ID resolved as shift
    END             reduce using rule 3 (optional_statements -> statements .)
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ;               reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]
  ! END             [ reduce using rule 80 (empty -> .) ]

    statement                      shift and go to state 48
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 23

    (4) optional_statements -> empty .
    (39) statement -> empty .

  ! reduce/reduce conflict for END resolved using rule 4 (optional_statements -> empty .)
    END             reduce using rule 4 (optional_statements -> empty .)
    ;               reduce using rule 39 (statement -> empty .)
    IF              reduce using rule 39 (statement -> empty .)
    WHILE           reduce using rule 39 (statement -> empty .)
    FOR             reduce using rule 39 (statement -> empty .)
    BEGIN           reduce using rule 39 (statement -> empty .)
    WRITELN         reduce using rule 39 (statement -> empty .)
    WRITE           reduce using rule 39 (statement -> empty .)
    READLN          reduce using rule 39 (statement -> empty .)
    ID              reduce using rule 39 (statement -> empty .)

  ! END             [ reduce using rule 39 (statement -> empty .) ]


state 24

    (29) statements -> statement . ;
    (30) statements -> statement .

  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 49
    IF              reduce using rule 30 (statements -> statement .)
    WHILE           reduce using rule 30 (statements -> statement .)
    FOR             reduce using rule 30 (statements -> statement .)
    BEGIN           reduce using rule 30 (statements -> statement .)
    WRITELN         reduce using rule 30 (statements -> statement .)
    WRITE           reduce using rule 30 (statements -> statement .)
    READLN          reduce using rule 30 (statements -> statement .)
    ID              reduce using rule 30 (statements -> statement .)
    END             reduce using rule 30 (statements -> statement .)

  ! ;               [ reduce using rule 30 (statements -> statement .) ]


state 25

    (31) statement -> assignment .

    ;               reduce using rule 31 (statement -> assignment .)
    IF              reduce using rule 31 (statement -> assignment .)
    WHILE           reduce using rule 31 (statement -> assignment .)
    FOR             reduce using rule 31 (statement -> assignment .)
    BEGIN           reduce using rule 31 (statement -> assignment .)
    WRITELN         reduce using rule 31 (statement -> assignment .)
    WRITE           reduce using rule 31 (statement -> assignment .)
    READLN          reduce using rule 31 (statement -> assignment .)
    ID              reduce using rule 31 (statement -> assignment .)
    END             reduce using rule 31 (statement -> assignment .)
    ELSE            reduce using rule 31 (statement -> assignment .)


state 26

    (32) statement -> if_statement .

    ;               reduce using rule 32 (statement -> if_statement .)
    IF              reduce using rule 32 (statement -> if_statement .)
    WHILE           reduce using rule 32 (statement -> if_statement .)
    FOR             reduce using rule 32 (statement -> if_statement .)
    BEGIN           reduce using rule 32 (statement -> if_statement .)
    WRITELN         reduce using rule 32 (statement -> if_statement .)
    WRITE           reduce using rule 32 (statement -> if_statement .)
    READLN          reduce using rule 32 (statement -> if_statement .)
    ID              reduce using rule 32 (statement -> if_statement .)
    END             reduce using rule 32 (statement -> if_statement .)
    ELSE            reduce using rule 32 (statement -> if_statement .)


state 27

    (33) statement -> while_loop .

    ;               reduce using rule 33 (statement -> while_loop .)
    IF              reduce using rule 33 (statement -> while_loop .)
    WHILE           reduce using rule 33 (statement -> while_loop .)
    FOR             reduce using rule 33 (statement -> while_loop .)
    BEGIN           reduce using rule 33 (statement -> while_loop .)
    WRITELN         reduce using rule 33 (statement -> while_loop .)
    WRITE           reduce using rule 33 (statement -> while_loop .)
    READLN          reduce using rule 33 (statement -> while_loop .)
    ID              reduce using rule 33 (statement -> while_loop .)
    END             reduce using rule 33 (statement -> while_loop .)
    ELSE            reduce using rule 33 (statement -> while_loop .)


state 28

    (34) statement -> for_loop .

    ;               reduce using rule 34 (statement -> for_loop .)
    IF              reduce using rule 34 (statement -> for_loop .)
    WHILE           reduce using rule 34 (statement -> for_loop .)
    FOR             reduce using rule 34 (statement -> for_loop .)
    BEGIN           reduce using rule 34 (statement -> for_loop .)
    WRITELN         reduce using rule 34 (statement -> for_loop .)
    WRITE           reduce using rule 34 (statement -> for_loop .)
    READLN          reduce using rule 34 (statement -> for_loop .)
    ID              reduce using rule 34 (statement -> for_loop .)
    END             reduce using rule 34 (statement -> for_loop .)
    ELSE            reduce using rule 34 (statement -> for_loop .)


state 29

    (35) statement -> compound_statement .

    ;               reduce using rule 35 (statement -> compound_statement .)
    IF              reduce using rule 35 (statement -> compound_statement .)
    WHILE           reduce using rule 35 (statement -> compound_statement .)
    FOR             reduce using rule 35 (statement -> compound_statement .)
    BEGIN           reduce using rule 35 (statement -> compound_statement .)
    WRITELN         reduce using rule 35 (statement -> compound_statement .)
    WRITE           reduce using rule 35 (statement -> compound_statement .)
    READLN          reduce using rule 35 (statement -> compound_statement .)
    ID              reduce using rule 35 (statement -> compound_statement .)
    END             reduce using rule 35 (statement -> compound_statement .)
    ELSE            reduce using rule 35 (statement -> compound_statement .)


state 30

    (36) statement -> writeln .

    ;               reduce using rule 36 (statement -> writeln .)
    IF              reduce using rule 36 (statement -> writeln .)
    WHILE           reduce using rule 36 (statement -> writeln .)
    FOR             reduce using rule 36 (statement -> writeln .)
    BEGIN           reduce using rule 36 (statement -> writeln .)
    WRITELN         reduce using rule 36 (statement -> writeln .)
    WRITE           reduce using rule 36 (statement -> writeln .)
    READLN          reduce using rule 36 (statement -> writeln .)
    ID              reduce using rule 36 (statement -> writeln .)
    END             reduce using rule 36 (statement -> writeln .)
    ELSE            reduce using rule 36 (statement -> writeln .)


state 31

    (37) statement -> write .

    ;               reduce using rule 37 (statement -> write .)
    IF              reduce using rule 37 (statement -> write .)
    WHILE           reduce using rule 37 (statement -> write .)
    FOR             reduce using rule 37 (statement -> write .)
    BEGIN           reduce using rule 37 (statement -> write .)
    WRITELN         reduce using rule 37 (statement -> write .)
    WRITE           reduce using rule 37 (statement -> write .)
    READLN          reduce using rule 37 (statement -> write .)
    ID              reduce using rule 37 (statement -> write .)
    END             reduce using rule 37 (statement -> write .)
    ELSE            reduce using rule 37 (statement -> write .)


state 32

    (38) statement -> readln .

    ;               reduce using rule 38 (statement -> readln .)
    IF              reduce using rule 38 (statement -> readln .)
    WHILE           reduce using rule 38 (statement -> readln .)
    FOR             reduce using rule 38 (statement -> readln .)
    BEGIN           reduce using rule 38 (statement -> readln .)
    WRITELN         reduce using rule 38 (statement -> readln .)
    WRITE           reduce using rule 38 (statement -> readln .)
    READLN          reduce using rule 38 (statement -> readln .)
    ID              reduce using rule 38 (statement -> readln .)
    END             reduce using rule 38 (statement -> readln .)
    ELSE            reduce using rule 38 (statement -> readln .)


state 33

    (40) assignment -> variable . ASSIGN expression
    (44) variable -> variable . LBRACKET expression RBRACKET

    ASSIGN          shift and go to state 50
    LBRACKET        shift and go to state 51


state 34

    (41) if_statement -> IF . expression THEN statement ELSE statement
    (42) if_statement -> IF . expression THEN statement
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 52
    variable                       shift and go to state 60

state 35

    (45) while_loop -> WHILE . expression DO statement
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 61
    variable                       shift and go to state 60

state 36

    (46) for_loop -> FOR . ID ASSIGN expression TO expression DO statement
    (47) for_loop -> FOR . ID ASSIGN expression DOWNTO expression DO statement

    ID              shift and go to state 62


state 37

    (43) variable -> ID .

    ASSIGN          reduce using rule 43 (variable -> ID .)
    LBRACKET        reduce using rule 43 (variable -> ID .)


state 38

    (50) writeln -> WRITELN . ( expression_list )

    (               shift and go to state 63


state 39

    (51) write -> WRITE . ( expression_list )

    (               shift and go to state 64


state 40

    (52) readln -> READLN . ( expression_list )

    (               shift and go to state 65


state 41

    (10) var_declarations -> var_declarations var_declaration .

    ID              reduce using rule 10 (var_declarations -> var_declarations var_declaration .)
    BEGIN           reduce using rule 10 (var_declarations -> var_declarations var_declaration .)
    VAR             reduce using rule 10 (var_declarations -> var_declarations var_declaration .)
    FUNCTION        reduce using rule 10 (var_declarations -> var_declarations var_declaration .)


state 42

    (22) var_declaration -> id_list : . type ;
    (23) type -> . INTEGER
    (24) type -> . BOOLEAN
    (25) type -> . STRING_TYPE
    (26) type -> . ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    INTEGER         shift and go to state 67
    BOOLEAN         shift and go to state 68
    STRING_TYPE     shift and go to state 69
    ARRAY           shift and go to state 70

    type                           shift and go to state 66

state 43

    (21) id_list -> id_list , . ID

    ID              shift and go to state 71


state 44

    (12) function_declaration -> FUNCTION ID ( . param_list_opt ) : type ; function_block ;
    (15) param_list_opt -> . param_list
    (16) param_list_opt -> . empty
    (17) param_list -> . param_list , param
    (18) param_list -> . param
    (80) empty -> .
    (19) param -> . ID : type

    )               reduce using rule 80 (empty -> .)
    ID              shift and go to state 72

    param_list_opt                 shift and go to state 73
    param_list                     shift and go to state 74
    empty                          shift and go to state 75
    param                          shift and go to state 76

state 45

    (48) compound_statement -> BEGIN statements . END
    (27) statements -> statements . statement ;
    (28) statements -> statements . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for END resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    END             shift and go to state 77
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ;               reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! END             [ reduce using rule 80 (empty -> .) ]
  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    statement                      shift and go to state 48
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 46

    (39) statement -> empty .

    ;               reduce using rule 39 (statement -> empty .)
    END             reduce using rule 39 (statement -> empty .)
    IF              reduce using rule 39 (statement -> empty .)
    WHILE           reduce using rule 39 (statement -> empty .)
    FOR             reduce using rule 39 (statement -> empty .)
    BEGIN           reduce using rule 39 (statement -> empty .)
    WRITELN         reduce using rule 39 (statement -> empty .)
    WRITE           reduce using rule 39 (statement -> empty .)
    READLN          reduce using rule 39 (statement -> empty .)
    ID              reduce using rule 39 (statement -> empty .)
    ELSE            reduce using rule 39 (statement -> empty .)


state 47

    (2) block -> declarations BEGIN optional_statements END .

    .               reduce using rule 2 (block -> declarations BEGIN optional_statements END .)


state 48

    (27) statements -> statements statement . ;
    (28) statements -> statements statement .

  ! shift/reduce conflict for ; resolved as shift
    ;               shift and go to state 78
    IF              reduce using rule 28 (statements -> statements statement .)
    WHILE           reduce using rule 28 (statements -> statements statement .)
    FOR             reduce using rule 28 (statements -> statements statement .)
    BEGIN           reduce using rule 28 (statements -> statements statement .)
    WRITELN         reduce using rule 28 (statements -> statements statement .)
    WRITE           reduce using rule 28 (statements -> statements statement .)
    READLN          reduce using rule 28 (statements -> statements statement .)
    ID              reduce using rule 28 (statements -> statements statement .)
    END             reduce using rule 28 (statements -> statements statement .)

  ! ;               [ reduce using rule 28 (statements -> statements statement .) ]


state 49

    (29) statements -> statement ; .

    IF              reduce using rule 29 (statements -> statement ; .)
    WHILE           reduce using rule 29 (statements -> statement ; .)
    FOR             reduce using rule 29 (statements -> statement ; .)
    BEGIN           reduce using rule 29 (statements -> statement ; .)
    WRITELN         reduce using rule 29 (statements -> statement ; .)
    WRITE           reduce using rule 29 (statements -> statement ; .)
    READLN          reduce using rule 29 (statements -> statement ; .)
    ID              reduce using rule 29 (statements -> statement ; .)
    ;               reduce using rule 29 (statements -> statement ; .)
    END             reduce using rule 29 (statements -> statement ; .)


state 50

    (40) assignment -> variable ASSIGN . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    variable                       shift and go to state 60
    expression                     shift and go to state 79

state 51

    (44) variable -> variable LBRACKET . expression RBRACKET
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    variable                       shift and go to state 60
    expression                     shift and go to state 80

state 52

    (41) if_statement -> IF expression . THEN statement ELSE statement
    (42) if_statement -> IF expression . THEN statement
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            shift and go to state 81
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 53

    (49) expression -> STRING .

    THEN            reduce using rule 49 (expression -> STRING .)
    +               reduce using rule 49 (expression -> STRING .)
    -               reduce using rule 49 (expression -> STRING .)
    *               reduce using rule 49 (expression -> STRING .)
    /               reduce using rule 49 (expression -> STRING .)
    DIV             reduce using rule 49 (expression -> STRING .)
    MOD             reduce using rule 49 (expression -> STRING .)
    AND             reduce using rule 49 (expression -> STRING .)
    OR              reduce using rule 49 (expression -> STRING .)
    =               reduce using rule 49 (expression -> STRING .)
    <               reduce using rule 49 (expression -> STRING .)
    >               reduce using rule 49 (expression -> STRING .)
    LE              reduce using rule 49 (expression -> STRING .)
    GE              reduce using rule 49 (expression -> STRING .)
    NE              reduce using rule 49 (expression -> STRING .)
    DO              reduce using rule 49 (expression -> STRING .)
    ;               reduce using rule 49 (expression -> STRING .)
    IF              reduce using rule 49 (expression -> STRING .)
    WHILE           reduce using rule 49 (expression -> STRING .)
    FOR             reduce using rule 49 (expression -> STRING .)
    BEGIN           reduce using rule 49 (expression -> STRING .)
    WRITELN         reduce using rule 49 (expression -> STRING .)
    WRITE           reduce using rule 49 (expression -> STRING .)
    READLN          reduce using rule 49 (expression -> STRING .)
    ID              reduce using rule 49 (expression -> STRING .)
    END             reduce using rule 49 (expression -> STRING .)
    ELSE            reduce using rule 49 (expression -> STRING .)
    RBRACKET        reduce using rule 49 (expression -> STRING .)
    )               reduce using rule 49 (expression -> STRING .)
    ,               reduce using rule 49 (expression -> STRING .)
    TO              reduce using rule 49 (expression -> STRING .)
    DOWNTO          reduce using rule 49 (expression -> STRING .)


state 54

    (67) expression -> NOT . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 96
    variable                       shift and go to state 60

state 55

    (68) expression -> ( . expression )
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 97
    variable                       shift and go to state 60

state 56

    (69) expression -> NUMBER .

    THEN            reduce using rule 69 (expression -> NUMBER .)
    +               reduce using rule 69 (expression -> NUMBER .)
    -               reduce using rule 69 (expression -> NUMBER .)
    *               reduce using rule 69 (expression -> NUMBER .)
    /               reduce using rule 69 (expression -> NUMBER .)
    DIV             reduce using rule 69 (expression -> NUMBER .)
    MOD             reduce using rule 69 (expression -> NUMBER .)
    AND             reduce using rule 69 (expression -> NUMBER .)
    OR              reduce using rule 69 (expression -> NUMBER .)
    =               reduce using rule 69 (expression -> NUMBER .)
    <               reduce using rule 69 (expression -> NUMBER .)
    >               reduce using rule 69 (expression -> NUMBER .)
    LE              reduce using rule 69 (expression -> NUMBER .)
    GE              reduce using rule 69 (expression -> NUMBER .)
    NE              reduce using rule 69 (expression -> NUMBER .)
    DO              reduce using rule 69 (expression -> NUMBER .)
    ;               reduce using rule 69 (expression -> NUMBER .)
    IF              reduce using rule 69 (expression -> NUMBER .)
    WHILE           reduce using rule 69 (expression -> NUMBER .)
    FOR             reduce using rule 69 (expression -> NUMBER .)
    BEGIN           reduce using rule 69 (expression -> NUMBER .)
    WRITELN         reduce using rule 69 (expression -> NUMBER .)
    WRITE           reduce using rule 69 (expression -> NUMBER .)
    READLN          reduce using rule 69 (expression -> NUMBER .)
    ID              reduce using rule 69 (expression -> NUMBER .)
    END             reduce using rule 69 (expression -> NUMBER .)
    ELSE            reduce using rule 69 (expression -> NUMBER .)
    RBRACKET        reduce using rule 69 (expression -> NUMBER .)
    )               reduce using rule 69 (expression -> NUMBER .)
    ,               reduce using rule 69 (expression -> NUMBER .)
    TO              reduce using rule 69 (expression -> NUMBER .)
    DOWNTO          reduce using rule 69 (expression -> NUMBER .)


state 57

    (70) expression -> TRUE .

    THEN            reduce using rule 70 (expression -> TRUE .)
    +               reduce using rule 70 (expression -> TRUE .)
    -               reduce using rule 70 (expression -> TRUE .)
    *               reduce using rule 70 (expression -> TRUE .)
    /               reduce using rule 70 (expression -> TRUE .)
    DIV             reduce using rule 70 (expression -> TRUE .)
    MOD             reduce using rule 70 (expression -> TRUE .)
    AND             reduce using rule 70 (expression -> TRUE .)
    OR              reduce using rule 70 (expression -> TRUE .)
    =               reduce using rule 70 (expression -> TRUE .)
    <               reduce using rule 70 (expression -> TRUE .)
    >               reduce using rule 70 (expression -> TRUE .)
    LE              reduce using rule 70 (expression -> TRUE .)
    GE              reduce using rule 70 (expression -> TRUE .)
    NE              reduce using rule 70 (expression -> TRUE .)
    DO              reduce using rule 70 (expression -> TRUE .)
    ;               reduce using rule 70 (expression -> TRUE .)
    IF              reduce using rule 70 (expression -> TRUE .)
    WHILE           reduce using rule 70 (expression -> TRUE .)
    FOR             reduce using rule 70 (expression -> TRUE .)
    BEGIN           reduce using rule 70 (expression -> TRUE .)
    WRITELN         reduce using rule 70 (expression -> TRUE .)
    WRITE           reduce using rule 70 (expression -> TRUE .)
    READLN          reduce using rule 70 (expression -> TRUE .)
    ID              reduce using rule 70 (expression -> TRUE .)
    END             reduce using rule 70 (expression -> TRUE .)
    ELSE            reduce using rule 70 (expression -> TRUE .)
    RBRACKET        reduce using rule 70 (expression -> TRUE .)
    )               reduce using rule 70 (expression -> TRUE .)
    ,               reduce using rule 70 (expression -> TRUE .)
    TO              reduce using rule 70 (expression -> TRUE .)
    DOWNTO          reduce using rule 70 (expression -> TRUE .)


state 58

    (71) expression -> FALSE .

    THEN            reduce using rule 71 (expression -> FALSE .)
    +               reduce using rule 71 (expression -> FALSE .)
    -               reduce using rule 71 (expression -> FALSE .)
    *               reduce using rule 71 (expression -> FALSE .)
    /               reduce using rule 71 (expression -> FALSE .)
    DIV             reduce using rule 71 (expression -> FALSE .)
    MOD             reduce using rule 71 (expression -> FALSE .)
    AND             reduce using rule 71 (expression -> FALSE .)
    OR              reduce using rule 71 (expression -> FALSE .)
    =               reduce using rule 71 (expression -> FALSE .)
    <               reduce using rule 71 (expression -> FALSE .)
    >               reduce using rule 71 (expression -> FALSE .)
    LE              reduce using rule 71 (expression -> FALSE .)
    GE              reduce using rule 71 (expression -> FALSE .)
    NE              reduce using rule 71 (expression -> FALSE .)
    DO              reduce using rule 71 (expression -> FALSE .)
    ;               reduce using rule 71 (expression -> FALSE .)
    IF              reduce using rule 71 (expression -> FALSE .)
    WHILE           reduce using rule 71 (expression -> FALSE .)
    FOR             reduce using rule 71 (expression -> FALSE .)
    BEGIN           reduce using rule 71 (expression -> FALSE .)
    WRITELN         reduce using rule 71 (expression -> FALSE .)
    WRITE           reduce using rule 71 (expression -> FALSE .)
    READLN          reduce using rule 71 (expression -> FALSE .)
    ID              reduce using rule 71 (expression -> FALSE .)
    END             reduce using rule 71 (expression -> FALSE .)
    ELSE            reduce using rule 71 (expression -> FALSE .)
    RBRACKET        reduce using rule 71 (expression -> FALSE .)
    )               reduce using rule 71 (expression -> FALSE .)
    ,               reduce using rule 71 (expression -> FALSE .)
    TO              reduce using rule 71 (expression -> FALSE .)
    DOWNTO          reduce using rule 71 (expression -> FALSE .)


state 59

    (72) expression -> ID . LBRACKET expression RBRACKET
    (74) expression -> ID .
    (77) expression -> ID . ( expression_list_opt )
    (43) variable -> ID .

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! reduce/reduce conflict for THEN resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for + resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for - resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for * resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for / resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for DIV resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for = resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for < resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for > resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for LE resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for GE resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for NE resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for DO resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for WHILE resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for BEGIN resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for WRITELN resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for WRITE resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for READLN resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for END resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for , resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for TO resolved using rule 43 (variable -> ID .)
  ! reduce/reduce conflict for DOWNTO resolved using rule 43 (variable -> ID .)
    LBRACKET        shift and go to state 98
    (               shift and go to state 99
    THEN            reduce using rule 43 (variable -> ID .)
    +               reduce using rule 43 (variable -> ID .)
    -               reduce using rule 43 (variable -> ID .)
    *               reduce using rule 43 (variable -> ID .)
    /               reduce using rule 43 (variable -> ID .)
    DIV             reduce using rule 43 (variable -> ID .)
    MOD             reduce using rule 43 (variable -> ID .)
    AND             reduce using rule 43 (variable -> ID .)
    OR              reduce using rule 43 (variable -> ID .)
    =               reduce using rule 43 (variable -> ID .)
    <               reduce using rule 43 (variable -> ID .)
    >               reduce using rule 43 (variable -> ID .)
    LE              reduce using rule 43 (variable -> ID .)
    GE              reduce using rule 43 (variable -> ID .)
    NE              reduce using rule 43 (variable -> ID .)
    DO              reduce using rule 43 (variable -> ID .)
    ;               reduce using rule 43 (variable -> ID .)
    IF              reduce using rule 43 (variable -> ID .)
    WHILE           reduce using rule 43 (variable -> ID .)
    FOR             reduce using rule 43 (variable -> ID .)
    BEGIN           reduce using rule 43 (variable -> ID .)
    WRITELN         reduce using rule 43 (variable -> ID .)
    WRITE           reduce using rule 43 (variable -> ID .)
    READLN          reduce using rule 43 (variable -> ID .)
    ID              reduce using rule 43 (variable -> ID .)
    END             reduce using rule 43 (variable -> ID .)
    ELSE            reduce using rule 43 (variable -> ID .)
    RBRACKET        reduce using rule 43 (variable -> ID .)
    )               reduce using rule 43 (variable -> ID .)
    ,               reduce using rule 43 (variable -> ID .)
    TO              reduce using rule 43 (variable -> ID .)
    DOWNTO          reduce using rule 43 (variable -> ID .)

  ! THEN            [ reduce using rule 74 (expression -> ID .) ]
  ! +               [ reduce using rule 74 (expression -> ID .) ]
  ! -               [ reduce using rule 74 (expression -> ID .) ]
  ! *               [ reduce using rule 74 (expression -> ID .) ]
  ! /               [ reduce using rule 74 (expression -> ID .) ]
  ! DIV             [ reduce using rule 74 (expression -> ID .) ]
  ! MOD             [ reduce using rule 74 (expression -> ID .) ]
  ! AND             [ reduce using rule 74 (expression -> ID .) ]
  ! OR              [ reduce using rule 74 (expression -> ID .) ]
  ! =               [ reduce using rule 74 (expression -> ID .) ]
  ! <               [ reduce using rule 74 (expression -> ID .) ]
  ! >               [ reduce using rule 74 (expression -> ID .) ]
  ! LE              [ reduce using rule 74 (expression -> ID .) ]
  ! GE              [ reduce using rule 74 (expression -> ID .) ]
  ! NE              [ reduce using rule 74 (expression -> ID .) ]
  ! DO              [ reduce using rule 74 (expression -> ID .) ]
  ! ;               [ reduce using rule 74 (expression -> ID .) ]
  ! IF              [ reduce using rule 74 (expression -> ID .) ]
  ! WHILE           [ reduce using rule 74 (expression -> ID .) ]
  ! FOR             [ reduce using rule 74 (expression -> ID .) ]
  ! BEGIN           [ reduce using rule 74 (expression -> ID .) ]
  ! WRITELN         [ reduce using rule 74 (expression -> ID .) ]
  ! WRITE           [ reduce using rule 74 (expression -> ID .) ]
  ! READLN          [ reduce using rule 74 (expression -> ID .) ]
  ! ID              [ reduce using rule 74 (expression -> ID .) ]
  ! END             [ reduce using rule 74 (expression -> ID .) ]
  ! ELSE            [ reduce using rule 74 (expression -> ID .) ]
  ! RBRACKET        [ reduce using rule 74 (expression -> ID .) ]
  ! )               [ reduce using rule 74 (expression -> ID .) ]
  ! ,               [ reduce using rule 74 (expression -> ID .) ]
  ! TO              [ reduce using rule 74 (expression -> ID .) ]
  ! DOWNTO          [ reduce using rule 74 (expression -> ID .) ]
  ! LBRACKET        [ reduce using rule 43 (variable -> ID .) ]


state 60

    (73) expression -> variable .
    (44) variable -> variable . LBRACKET expression RBRACKET

    THEN            reduce using rule 73 (expression -> variable .)
    +               reduce using rule 73 (expression -> variable .)
    -               reduce using rule 73 (expression -> variable .)
    *               reduce using rule 73 (expression -> variable .)
    /               reduce using rule 73 (expression -> variable .)
    DIV             reduce using rule 73 (expression -> variable .)
    MOD             reduce using rule 73 (expression -> variable .)
    AND             reduce using rule 73 (expression -> variable .)
    OR              reduce using rule 73 (expression -> variable .)
    =               reduce using rule 73 (expression -> variable .)
    <               reduce using rule 73 (expression -> variable .)
    >               reduce using rule 73 (expression -> variable .)
    LE              reduce using rule 73 (expression -> variable .)
    GE              reduce using rule 73 (expression -> variable .)
    NE              reduce using rule 73 (expression -> variable .)
    DO              reduce using rule 73 (expression -> variable .)
    ;               reduce using rule 73 (expression -> variable .)
    IF              reduce using rule 73 (expression -> variable .)
    WHILE           reduce using rule 73 (expression -> variable .)
    FOR             reduce using rule 73 (expression -> variable .)
    BEGIN           reduce using rule 73 (expression -> variable .)
    WRITELN         reduce using rule 73 (expression -> variable .)
    WRITE           reduce using rule 73 (expression -> variable .)
    READLN          reduce using rule 73 (expression -> variable .)
    ID              reduce using rule 73 (expression -> variable .)
    END             reduce using rule 73 (expression -> variable .)
    ELSE            reduce using rule 73 (expression -> variable .)
    RBRACKET        reduce using rule 73 (expression -> variable .)
    )               reduce using rule 73 (expression -> variable .)
    ,               reduce using rule 73 (expression -> variable .)
    TO              reduce using rule 73 (expression -> variable .)
    DOWNTO          reduce using rule 73 (expression -> variable .)
    LBRACKET        shift and go to state 51


state 61

    (45) while_loop -> WHILE expression . DO statement
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    DO              shift and go to state 100
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 62

    (46) for_loop -> FOR ID . ASSIGN expression TO expression DO statement
    (47) for_loop -> FOR ID . ASSIGN expression DOWNTO expression DO statement

    ASSIGN          shift and go to state 101


state 63

    (50) writeln -> WRITELN ( . expression_list )
    (75) expression_list -> . expression
    (76) expression_list -> . expression_list , expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression_list                shift and go to state 102
    expression                     shift and go to state 103
    variable                       shift and go to state 60

state 64

    (51) write -> WRITE ( . expression_list )
    (75) expression_list -> . expression
    (76) expression_list -> . expression_list , expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression_list                shift and go to state 104
    expression                     shift and go to state 103
    variable                       shift and go to state 60

state 65

    (52) readln -> READLN ( . expression_list )
    (75) expression_list -> . expression
    (76) expression_list -> . expression_list , expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression_list                shift and go to state 105
    expression                     shift and go to state 103
    variable                       shift and go to state 60

state 66

    (22) var_declaration -> id_list : type . ;

    ;               shift and go to state 106


state 67

    (23) type -> INTEGER .

    ;               reduce using rule 23 (type -> INTEGER .)
    ,               reduce using rule 23 (type -> INTEGER .)
    )               reduce using rule 23 (type -> INTEGER .)


state 68

    (24) type -> BOOLEAN .

    ;               reduce using rule 24 (type -> BOOLEAN .)
    ,               reduce using rule 24 (type -> BOOLEAN .)
    )               reduce using rule 24 (type -> BOOLEAN .)


state 69

    (25) type -> STRING_TYPE .

    ;               reduce using rule 25 (type -> STRING_TYPE .)
    ,               reduce using rule 25 (type -> STRING_TYPE .)
    )               reduce using rule 25 (type -> STRING_TYPE .)


state 70

    (26) type -> ARRAY . LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    LBRACKET        shift and go to state 107


state 71

    (21) id_list -> id_list , ID .

    :               reduce using rule 21 (id_list -> id_list , ID .)
    ,               reduce using rule 21 (id_list -> id_list , ID .)


state 72

    (19) param -> ID . : type

    :               shift and go to state 108


state 73

    (12) function_declaration -> FUNCTION ID ( param_list_opt . ) : type ; function_block ;

    )               shift and go to state 109


state 74

    (15) param_list_opt -> param_list .
    (17) param_list -> param_list . , param

    )               reduce using rule 15 (param_list_opt -> param_list .)
    ,               shift and go to state 110


state 75

    (16) param_list_opt -> empty .

    )               reduce using rule 16 (param_list_opt -> empty .)


state 76

    (18) param_list -> param .

    ,               reduce using rule 18 (param_list -> param .)
    )               reduce using rule 18 (param_list -> param .)


state 77

    (48) compound_statement -> BEGIN statements END .

    ;               reduce using rule 48 (compound_statement -> BEGIN statements END .)
    IF              reduce using rule 48 (compound_statement -> BEGIN statements END .)
    WHILE           reduce using rule 48 (compound_statement -> BEGIN statements END .)
    FOR             reduce using rule 48 (compound_statement -> BEGIN statements END .)
    BEGIN           reduce using rule 48 (compound_statement -> BEGIN statements END .)
    WRITELN         reduce using rule 48 (compound_statement -> BEGIN statements END .)
    WRITE           reduce using rule 48 (compound_statement -> BEGIN statements END .)
    READLN          reduce using rule 48 (compound_statement -> BEGIN statements END .)
    ID              reduce using rule 48 (compound_statement -> BEGIN statements END .)
    END             reduce using rule 48 (compound_statement -> BEGIN statements END .)
    ELSE            reduce using rule 48 (compound_statement -> BEGIN statements END .)


state 78

    (27) statements -> statements statement ; .

    IF              reduce using rule 27 (statements -> statements statement ; .)
    WHILE           reduce using rule 27 (statements -> statements statement ; .)
    FOR             reduce using rule 27 (statements -> statements statement ; .)
    BEGIN           reduce using rule 27 (statements -> statements statement ; .)
    WRITELN         reduce using rule 27 (statements -> statements statement ; .)
    WRITE           reduce using rule 27 (statements -> statements statement ; .)
    READLN          reduce using rule 27 (statements -> statements statement ; .)
    ID              reduce using rule 27 (statements -> statements statement ; .)
    ;               reduce using rule 27 (statements -> statements statement ; .)
    END             reduce using rule 27 (statements -> statements statement ; .)


state 79

    (40) assignment -> variable ASSIGN expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    ;               reduce using rule 40 (assignment -> variable ASSIGN expression .)
    IF              reduce using rule 40 (assignment -> variable ASSIGN expression .)
    WHILE           reduce using rule 40 (assignment -> variable ASSIGN expression .)
    FOR             reduce using rule 40 (assignment -> variable ASSIGN expression .)
    BEGIN           reduce using rule 40 (assignment -> variable ASSIGN expression .)
    WRITELN         reduce using rule 40 (assignment -> variable ASSIGN expression .)
    WRITE           reduce using rule 40 (assignment -> variable ASSIGN expression .)
    READLN          reduce using rule 40 (assignment -> variable ASSIGN expression .)
    ID              reduce using rule 40 (assignment -> variable ASSIGN expression .)
    END             reduce using rule 40 (assignment -> variable ASSIGN expression .)
    ELSE            reduce using rule 40 (assignment -> variable ASSIGN expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 80

    (44) variable -> variable LBRACKET expression . RBRACKET
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    RBRACKET        shift and go to state 111
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 81

    (41) if_statement -> IF expression THEN . statement ELSE statement
    (42) if_statement -> IF expression THEN . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ELSE            reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    END             reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    statement                      shift and go to state 112
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 82

    (53) expression -> expression + . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 113
    variable                       shift and go to state 60

state 83

    (54) expression -> expression - . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 114
    variable                       shift and go to state 60

state 84

    (55) expression -> expression * . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 115
    variable                       shift and go to state 60

state 85

    (56) expression -> expression / . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 116
    variable                       shift and go to state 60

state 86

    (57) expression -> expression DIV . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 117
    variable                       shift and go to state 60

state 87

    (58) expression -> expression MOD . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 118
    variable                       shift and go to state 60

state 88

    (59) expression -> expression AND . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 119
    variable                       shift and go to state 60

state 89

    (60) expression -> expression OR . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 120
    variable                       shift and go to state 60

state 90

    (61) expression -> expression = . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 121
    variable                       shift and go to state 60

state 91

    (62) expression -> expression < . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 122
    variable                       shift and go to state 60

state 92

    (63) expression -> expression > . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 123
    variable                       shift and go to state 60

state 93

    (64) expression -> expression LE . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 124
    variable                       shift and go to state 60

state 94

    (65) expression -> expression GE . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 125
    variable                       shift and go to state 60

state 95

    (66) expression -> expression NE . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 126
    variable                       shift and go to state 60

state 96

    (67) expression -> NOT expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 67 (expression -> NOT expression .)
    AND             reduce using rule 67 (expression -> NOT expression .)
    OR              reduce using rule 67 (expression -> NOT expression .)
    DO              reduce using rule 67 (expression -> NOT expression .)
    ;               reduce using rule 67 (expression -> NOT expression .)
    IF              reduce using rule 67 (expression -> NOT expression .)
    WHILE           reduce using rule 67 (expression -> NOT expression .)
    FOR             reduce using rule 67 (expression -> NOT expression .)
    BEGIN           reduce using rule 67 (expression -> NOT expression .)
    WRITELN         reduce using rule 67 (expression -> NOT expression .)
    WRITE           reduce using rule 67 (expression -> NOT expression .)
    READLN          reduce using rule 67 (expression -> NOT expression .)
    ID              reduce using rule 67 (expression -> NOT expression .)
    END             reduce using rule 67 (expression -> NOT expression .)
    ELSE            reduce using rule 67 (expression -> NOT expression .)
    RBRACKET        reduce using rule 67 (expression -> NOT expression .)
    )               reduce using rule 67 (expression -> NOT expression .)
    ,               reduce using rule 67 (expression -> NOT expression .)
    TO              reduce using rule 67 (expression -> NOT expression .)
    DOWNTO          reduce using rule 67 (expression -> NOT expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95

  ! +               [ reduce using rule 67 (expression -> NOT expression .) ]
  ! -               [ reduce using rule 67 (expression -> NOT expression .) ]
  ! *               [ reduce using rule 67 (expression -> NOT expression .) ]
  ! /               [ reduce using rule 67 (expression -> NOT expression .) ]
  ! DIV             [ reduce using rule 67 (expression -> NOT expression .) ]
  ! MOD             [ reduce using rule 67 (expression -> NOT expression .) ]
  ! =               [ reduce using rule 67 (expression -> NOT expression .) ]
  ! <               [ reduce using rule 67 (expression -> NOT expression .) ]
  ! >               [ reduce using rule 67 (expression -> NOT expression .) ]
  ! LE              [ reduce using rule 67 (expression -> NOT expression .) ]
  ! GE              [ reduce using rule 67 (expression -> NOT expression .) ]
  ! NE              [ reduce using rule 67 (expression -> NOT expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]


state 97

    (68) expression -> ( expression . )
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    )               shift and go to state 127
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 98

    (72) expression -> ID LBRACKET . expression RBRACKET
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 128
    variable                       shift and go to state 60

state 99

    (77) expression -> ID ( . expression_list_opt )
    (78) expression_list_opt -> . expression_list
    (79) expression_list_opt -> . empty
    (75) expression_list -> . expression
    (76) expression_list -> . expression_list , expression
    (80) empty -> .
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    )               reduce using rule 80 (empty -> .)
    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression_list_opt            shift and go to state 129
    expression_list                shift and go to state 130
    empty                          shift and go to state 131
    expression                     shift and go to state 103
    variable                       shift and go to state 60

state 100

    (45) while_loop -> WHILE expression DO . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ELSE            reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    END             reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    statement                      shift and go to state 132
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 101

    (46) for_loop -> FOR ID ASSIGN . expression TO expression DO statement
    (47) for_loop -> FOR ID ASSIGN . expression DOWNTO expression DO statement
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 133
    variable                       shift and go to state 60

state 102

    (50) writeln -> WRITELN ( expression_list . )
    (76) expression_list -> expression_list . , expression

    )               shift and go to state 134
    ,               shift and go to state 135


state 103

    (75) expression_list -> expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    )               reduce using rule 75 (expression_list -> expression .)
    ,               reduce using rule 75 (expression_list -> expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 104

    (51) write -> WRITE ( expression_list . )
    (76) expression_list -> expression_list . , expression

    )               shift and go to state 136
    ,               shift and go to state 135


state 105

    (52) readln -> READLN ( expression_list . )
    (76) expression_list -> expression_list . , expression

    )               shift and go to state 137
    ,               shift and go to state 135


state 106

    (22) var_declaration -> id_list : type ; .

    ID              reduce using rule 22 (var_declaration -> id_list : type ; .)
    BEGIN           reduce using rule 22 (var_declaration -> id_list : type ; .)
    VAR             reduce using rule 22 (var_declaration -> id_list : type ; .)
    FUNCTION        reduce using rule 22 (var_declaration -> id_list : type ; .)


state 107

    (26) type -> ARRAY LBRACKET . NUMBER DOTDOT NUMBER RBRACKET OF type

    NUMBER          shift and go to state 138


state 108

    (19) param -> ID : . type
    (23) type -> . INTEGER
    (24) type -> . BOOLEAN
    (25) type -> . STRING_TYPE
    (26) type -> . ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    INTEGER         shift and go to state 67
    BOOLEAN         shift and go to state 68
    STRING_TYPE     shift and go to state 69
    ARRAY           shift and go to state 70

    type                           shift and go to state 139

state 109

    (12) function_declaration -> FUNCTION ID ( param_list_opt ) . : type ; function_block ;

    :               shift and go to state 140


state 110

    (17) param_list -> param_list , . param
    (19) param -> . ID : type

    ID              shift and go to state 72

    param                          shift and go to state 141

state 111

    (44) variable -> variable LBRACKET expression RBRACKET .

    ASSIGN          reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    THEN            reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    +               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    -               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    *               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    /               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    DIV             reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    MOD             reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    AND             reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    OR              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    =               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    <               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    >               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    LE              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    GE              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    NE              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    DO              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    ;               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    IF              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    WHILE           reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    FOR             reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    BEGIN           reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    WRITELN         reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    WRITE           reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    READLN          reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    ID              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    END             reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    )               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    ,               reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    TO              reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)
    DOWNTO          reduce using rule 44 (variable -> variable LBRACKET expression RBRACKET .)


state 112

    (41) if_statement -> IF expression THEN statement . ELSE statement
    (42) if_statement -> IF expression THEN statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 142
    ;               reduce using rule 42 (if_statement -> IF expression THEN statement .)
    IF              reduce using rule 42 (if_statement -> IF expression THEN statement .)
    WHILE           reduce using rule 42 (if_statement -> IF expression THEN statement .)
    FOR             reduce using rule 42 (if_statement -> IF expression THEN statement .)
    BEGIN           reduce using rule 42 (if_statement -> IF expression THEN statement .)
    WRITELN         reduce using rule 42 (if_statement -> IF expression THEN statement .)
    WRITE           reduce using rule 42 (if_statement -> IF expression THEN statement .)
    READLN          reduce using rule 42 (if_statement -> IF expression THEN statement .)
    ID              reduce using rule 42 (if_statement -> IF expression THEN statement .)
    END             reduce using rule 42 (if_statement -> IF expression THEN statement .)

  ! ELSE            [ reduce using rule 42 (if_statement -> IF expression THEN statement .) ]


state 113

    (53) expression -> expression + expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 53 (expression -> expression + expression .)
    +               reduce using rule 53 (expression -> expression + expression .)
    -               reduce using rule 53 (expression -> expression + expression .)
    AND             reduce using rule 53 (expression -> expression + expression .)
    OR              reduce using rule 53 (expression -> expression + expression .)
    =               reduce using rule 53 (expression -> expression + expression .)
    <               reduce using rule 53 (expression -> expression + expression .)
    >               reduce using rule 53 (expression -> expression + expression .)
    LE              reduce using rule 53 (expression -> expression + expression .)
    GE              reduce using rule 53 (expression -> expression + expression .)
    NE              reduce using rule 53 (expression -> expression + expression .)
    DO              reduce using rule 53 (expression -> expression + expression .)
    ;               reduce using rule 53 (expression -> expression + expression .)
    IF              reduce using rule 53 (expression -> expression + expression .)
    WHILE           reduce using rule 53 (expression -> expression + expression .)
    FOR             reduce using rule 53 (expression -> expression + expression .)
    BEGIN           reduce using rule 53 (expression -> expression + expression .)
    WRITELN         reduce using rule 53 (expression -> expression + expression .)
    WRITE           reduce using rule 53 (expression -> expression + expression .)
    READLN          reduce using rule 53 (expression -> expression + expression .)
    ID              reduce using rule 53 (expression -> expression + expression .)
    END             reduce using rule 53 (expression -> expression + expression .)
    ELSE            reduce using rule 53 (expression -> expression + expression .)
    RBRACKET        reduce using rule 53 (expression -> expression + expression .)
    )               reduce using rule 53 (expression -> expression + expression .)
    ,               reduce using rule 53 (expression -> expression + expression .)
    TO              reduce using rule 53 (expression -> expression + expression .)
    DOWNTO          reduce using rule 53 (expression -> expression + expression .)
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! *               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 53 (expression -> expression + expression .) ]
  ! DIV             [ reduce using rule 53 (expression -> expression + expression .) ]
  ! MOD             [ reduce using rule 53 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 82 ]
  ! -               [ shift and go to state 83 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 114

    (54) expression -> expression - expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 54 (expression -> expression - expression .)
    +               reduce using rule 54 (expression -> expression - expression .)
    -               reduce using rule 54 (expression -> expression - expression .)
    AND             reduce using rule 54 (expression -> expression - expression .)
    OR              reduce using rule 54 (expression -> expression - expression .)
    =               reduce using rule 54 (expression -> expression - expression .)
    <               reduce using rule 54 (expression -> expression - expression .)
    >               reduce using rule 54 (expression -> expression - expression .)
    LE              reduce using rule 54 (expression -> expression - expression .)
    GE              reduce using rule 54 (expression -> expression - expression .)
    NE              reduce using rule 54 (expression -> expression - expression .)
    DO              reduce using rule 54 (expression -> expression - expression .)
    ;               reduce using rule 54 (expression -> expression - expression .)
    IF              reduce using rule 54 (expression -> expression - expression .)
    WHILE           reduce using rule 54 (expression -> expression - expression .)
    FOR             reduce using rule 54 (expression -> expression - expression .)
    BEGIN           reduce using rule 54 (expression -> expression - expression .)
    WRITELN         reduce using rule 54 (expression -> expression - expression .)
    WRITE           reduce using rule 54 (expression -> expression - expression .)
    READLN          reduce using rule 54 (expression -> expression - expression .)
    ID              reduce using rule 54 (expression -> expression - expression .)
    END             reduce using rule 54 (expression -> expression - expression .)
    ELSE            reduce using rule 54 (expression -> expression - expression .)
    RBRACKET        reduce using rule 54 (expression -> expression - expression .)
    )               reduce using rule 54 (expression -> expression - expression .)
    ,               reduce using rule 54 (expression -> expression - expression .)
    TO              reduce using rule 54 (expression -> expression - expression .)
    DOWNTO          reduce using rule 54 (expression -> expression - expression .)
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! *               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 54 (expression -> expression - expression .) ]
  ! DIV             [ reduce using rule 54 (expression -> expression - expression .) ]
  ! MOD             [ reduce using rule 54 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 82 ]
  ! -               [ shift and go to state 83 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 115

    (55) expression -> expression * expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 55 (expression -> expression * expression .)
    +               reduce using rule 55 (expression -> expression * expression .)
    -               reduce using rule 55 (expression -> expression * expression .)
    *               reduce using rule 55 (expression -> expression * expression .)
    /               reduce using rule 55 (expression -> expression * expression .)
    DIV             reduce using rule 55 (expression -> expression * expression .)
    MOD             reduce using rule 55 (expression -> expression * expression .)
    AND             reduce using rule 55 (expression -> expression * expression .)
    OR              reduce using rule 55 (expression -> expression * expression .)
    =               reduce using rule 55 (expression -> expression * expression .)
    <               reduce using rule 55 (expression -> expression * expression .)
    >               reduce using rule 55 (expression -> expression * expression .)
    LE              reduce using rule 55 (expression -> expression * expression .)
    GE              reduce using rule 55 (expression -> expression * expression .)
    NE              reduce using rule 55 (expression -> expression * expression .)
    DO              reduce using rule 55 (expression -> expression * expression .)
    ;               reduce using rule 55 (expression -> expression * expression .)
    IF              reduce using rule 55 (expression -> expression * expression .)
    WHILE           reduce using rule 55 (expression -> expression * expression .)
    FOR             reduce using rule 55 (expression -> expression * expression .)
    BEGIN           reduce using rule 55 (expression -> expression * expression .)
    WRITELN         reduce using rule 55 (expression -> expression * expression .)
    WRITE           reduce using rule 55 (expression -> expression * expression .)
    READLN          reduce using rule 55 (expression -> expression * expression .)
    ID              reduce using rule 55 (expression -> expression * expression .)
    END             reduce using rule 55 (expression -> expression * expression .)
    ELSE            reduce using rule 55 (expression -> expression * expression .)
    RBRACKET        reduce using rule 55 (expression -> expression * expression .)
    )               reduce using rule 55 (expression -> expression * expression .)
    ,               reduce using rule 55 (expression -> expression * expression .)
    TO              reduce using rule 55 (expression -> expression * expression .)
    DOWNTO          reduce using rule 55 (expression -> expression * expression .)

  ! +               [ shift and go to state 82 ]
  ! -               [ shift and go to state 83 ]
  ! *               [ shift and go to state 84 ]
  ! /               [ shift and go to state 85 ]
  ! DIV             [ shift and go to state 86 ]
  ! MOD             [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 116

    (56) expression -> expression / expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 56 (expression -> expression / expression .)
    +               reduce using rule 56 (expression -> expression / expression .)
    -               reduce using rule 56 (expression -> expression / expression .)
    *               reduce using rule 56 (expression -> expression / expression .)
    /               reduce using rule 56 (expression -> expression / expression .)
    DIV             reduce using rule 56 (expression -> expression / expression .)
    MOD             reduce using rule 56 (expression -> expression / expression .)
    AND             reduce using rule 56 (expression -> expression / expression .)
    OR              reduce using rule 56 (expression -> expression / expression .)
    =               reduce using rule 56 (expression -> expression / expression .)
    <               reduce using rule 56 (expression -> expression / expression .)
    >               reduce using rule 56 (expression -> expression / expression .)
    LE              reduce using rule 56 (expression -> expression / expression .)
    GE              reduce using rule 56 (expression -> expression / expression .)
    NE              reduce using rule 56 (expression -> expression / expression .)
    DO              reduce using rule 56 (expression -> expression / expression .)
    ;               reduce using rule 56 (expression -> expression / expression .)
    IF              reduce using rule 56 (expression -> expression / expression .)
    WHILE           reduce using rule 56 (expression -> expression / expression .)
    FOR             reduce using rule 56 (expression -> expression / expression .)
    BEGIN           reduce using rule 56 (expression -> expression / expression .)
    WRITELN         reduce using rule 56 (expression -> expression / expression .)
    WRITE           reduce using rule 56 (expression -> expression / expression .)
    READLN          reduce using rule 56 (expression -> expression / expression .)
    ID              reduce using rule 56 (expression -> expression / expression .)
    END             reduce using rule 56 (expression -> expression / expression .)
    ELSE            reduce using rule 56 (expression -> expression / expression .)
    RBRACKET        reduce using rule 56 (expression -> expression / expression .)
    )               reduce using rule 56 (expression -> expression / expression .)
    ,               reduce using rule 56 (expression -> expression / expression .)
    TO              reduce using rule 56 (expression -> expression / expression .)
    DOWNTO          reduce using rule 56 (expression -> expression / expression .)

  ! +               [ shift and go to state 82 ]
  ! -               [ shift and go to state 83 ]
  ! *               [ shift and go to state 84 ]
  ! /               [ shift and go to state 85 ]
  ! DIV             [ shift and go to state 86 ]
  ! MOD             [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 117

    (57) expression -> expression DIV expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 57 (expression -> expression DIV expression .)
    +               reduce using rule 57 (expression -> expression DIV expression .)
    -               reduce using rule 57 (expression -> expression DIV expression .)
    *               reduce using rule 57 (expression -> expression DIV expression .)
    /               reduce using rule 57 (expression -> expression DIV expression .)
    DIV             reduce using rule 57 (expression -> expression DIV expression .)
    MOD             reduce using rule 57 (expression -> expression DIV expression .)
    AND             reduce using rule 57 (expression -> expression DIV expression .)
    OR              reduce using rule 57 (expression -> expression DIV expression .)
    =               reduce using rule 57 (expression -> expression DIV expression .)
    <               reduce using rule 57 (expression -> expression DIV expression .)
    >               reduce using rule 57 (expression -> expression DIV expression .)
    LE              reduce using rule 57 (expression -> expression DIV expression .)
    GE              reduce using rule 57 (expression -> expression DIV expression .)
    NE              reduce using rule 57 (expression -> expression DIV expression .)
    DO              reduce using rule 57 (expression -> expression DIV expression .)
    ;               reduce using rule 57 (expression -> expression DIV expression .)
    IF              reduce using rule 57 (expression -> expression DIV expression .)
    WHILE           reduce using rule 57 (expression -> expression DIV expression .)
    FOR             reduce using rule 57 (expression -> expression DIV expression .)
    BEGIN           reduce using rule 57 (expression -> expression DIV expression .)
    WRITELN         reduce using rule 57 (expression -> expression DIV expression .)
    WRITE           reduce using rule 57 (expression -> expression DIV expression .)
    READLN          reduce using rule 57 (expression -> expression DIV expression .)
    ID              reduce using rule 57 (expression -> expression DIV expression .)
    END             reduce using rule 57 (expression -> expression DIV expression .)
    ELSE            reduce using rule 57 (expression -> expression DIV expression .)
    RBRACKET        reduce using rule 57 (expression -> expression DIV expression .)
    )               reduce using rule 57 (expression -> expression DIV expression .)
    ,               reduce using rule 57 (expression -> expression DIV expression .)
    TO              reduce using rule 57 (expression -> expression DIV expression .)
    DOWNTO          reduce using rule 57 (expression -> expression DIV expression .)

  ! +               [ shift and go to state 82 ]
  ! -               [ shift and go to state 83 ]
  ! *               [ shift and go to state 84 ]
  ! /               [ shift and go to state 85 ]
  ! DIV             [ shift and go to state 86 ]
  ! MOD             [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 118

    (58) expression -> expression MOD expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 58 (expression -> expression MOD expression .)
    +               reduce using rule 58 (expression -> expression MOD expression .)
    -               reduce using rule 58 (expression -> expression MOD expression .)
    *               reduce using rule 58 (expression -> expression MOD expression .)
    /               reduce using rule 58 (expression -> expression MOD expression .)
    DIV             reduce using rule 58 (expression -> expression MOD expression .)
    MOD             reduce using rule 58 (expression -> expression MOD expression .)
    AND             reduce using rule 58 (expression -> expression MOD expression .)
    OR              reduce using rule 58 (expression -> expression MOD expression .)
    =               reduce using rule 58 (expression -> expression MOD expression .)
    <               reduce using rule 58 (expression -> expression MOD expression .)
    >               reduce using rule 58 (expression -> expression MOD expression .)
    LE              reduce using rule 58 (expression -> expression MOD expression .)
    GE              reduce using rule 58 (expression -> expression MOD expression .)
    NE              reduce using rule 58 (expression -> expression MOD expression .)
    DO              reduce using rule 58 (expression -> expression MOD expression .)
    ;               reduce using rule 58 (expression -> expression MOD expression .)
    IF              reduce using rule 58 (expression -> expression MOD expression .)
    WHILE           reduce using rule 58 (expression -> expression MOD expression .)
    FOR             reduce using rule 58 (expression -> expression MOD expression .)
    BEGIN           reduce using rule 58 (expression -> expression MOD expression .)
    WRITELN         reduce using rule 58 (expression -> expression MOD expression .)
    WRITE           reduce using rule 58 (expression -> expression MOD expression .)
    READLN          reduce using rule 58 (expression -> expression MOD expression .)
    ID              reduce using rule 58 (expression -> expression MOD expression .)
    END             reduce using rule 58 (expression -> expression MOD expression .)
    ELSE            reduce using rule 58 (expression -> expression MOD expression .)
    RBRACKET        reduce using rule 58 (expression -> expression MOD expression .)
    )               reduce using rule 58 (expression -> expression MOD expression .)
    ,               reduce using rule 58 (expression -> expression MOD expression .)
    TO              reduce using rule 58 (expression -> expression MOD expression .)
    DOWNTO          reduce using rule 58 (expression -> expression MOD expression .)

  ! +               [ shift and go to state 82 ]
  ! -               [ shift and go to state 83 ]
  ! *               [ shift and go to state 84 ]
  ! /               [ shift and go to state 85 ]
  ! DIV             [ shift and go to state 86 ]
  ! MOD             [ shift and go to state 87 ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 119

    (59) expression -> expression AND expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 59 (expression -> expression AND expression .)
    AND             reduce using rule 59 (expression -> expression AND expression .)
    OR              reduce using rule 59 (expression -> expression AND expression .)
    DO              reduce using rule 59 (expression -> expression AND expression .)
    ;               reduce using rule 59 (expression -> expression AND expression .)
    IF              reduce using rule 59 (expression -> expression AND expression .)
    WHILE           reduce using rule 59 (expression -> expression AND expression .)
    FOR             reduce using rule 59 (expression -> expression AND expression .)
    BEGIN           reduce using rule 59 (expression -> expression AND expression .)
    WRITELN         reduce using rule 59 (expression -> expression AND expression .)
    WRITE           reduce using rule 59 (expression -> expression AND expression .)
    READLN          reduce using rule 59 (expression -> expression AND expression .)
    ID              reduce using rule 59 (expression -> expression AND expression .)
    END             reduce using rule 59 (expression -> expression AND expression .)
    ELSE            reduce using rule 59 (expression -> expression AND expression .)
    RBRACKET        reduce using rule 59 (expression -> expression AND expression .)
    )               reduce using rule 59 (expression -> expression AND expression .)
    ,               reduce using rule 59 (expression -> expression AND expression .)
    TO              reduce using rule 59 (expression -> expression AND expression .)
    DOWNTO          reduce using rule 59 (expression -> expression AND expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95

  ! +               [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! DIV             [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! MOD             [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! =               [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! NE              [ reduce using rule 59 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]


state 120

    (60) expression -> expression OR expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 60 (expression -> expression OR expression .)
    OR              reduce using rule 60 (expression -> expression OR expression .)
    DO              reduce using rule 60 (expression -> expression OR expression .)
    ;               reduce using rule 60 (expression -> expression OR expression .)
    IF              reduce using rule 60 (expression -> expression OR expression .)
    WHILE           reduce using rule 60 (expression -> expression OR expression .)
    FOR             reduce using rule 60 (expression -> expression OR expression .)
    BEGIN           reduce using rule 60 (expression -> expression OR expression .)
    WRITELN         reduce using rule 60 (expression -> expression OR expression .)
    WRITE           reduce using rule 60 (expression -> expression OR expression .)
    READLN          reduce using rule 60 (expression -> expression OR expression .)
    ID              reduce using rule 60 (expression -> expression OR expression .)
    END             reduce using rule 60 (expression -> expression OR expression .)
    ELSE            reduce using rule 60 (expression -> expression OR expression .)
    RBRACKET        reduce using rule 60 (expression -> expression OR expression .)
    )               reduce using rule 60 (expression -> expression OR expression .)
    ,               reduce using rule 60 (expression -> expression OR expression .)
    TO              reduce using rule 60 (expression -> expression OR expression .)
    DOWNTO          reduce using rule 60 (expression -> expression OR expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95

  ! +               [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! DIV             [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! MOD             [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! =               [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! NE              [ reduce using rule 60 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 89 ]


state 121

    (61) expression -> expression = expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 61 (expression -> expression = expression .)
    AND             reduce using rule 61 (expression -> expression = expression .)
    OR              reduce using rule 61 (expression -> expression = expression .)
    =               reduce using rule 61 (expression -> expression = expression .)
    <               reduce using rule 61 (expression -> expression = expression .)
    >               reduce using rule 61 (expression -> expression = expression .)
    LE              reduce using rule 61 (expression -> expression = expression .)
    GE              reduce using rule 61 (expression -> expression = expression .)
    NE              reduce using rule 61 (expression -> expression = expression .)
    DO              reduce using rule 61 (expression -> expression = expression .)
    ;               reduce using rule 61 (expression -> expression = expression .)
    IF              reduce using rule 61 (expression -> expression = expression .)
    WHILE           reduce using rule 61 (expression -> expression = expression .)
    FOR             reduce using rule 61 (expression -> expression = expression .)
    BEGIN           reduce using rule 61 (expression -> expression = expression .)
    WRITELN         reduce using rule 61 (expression -> expression = expression .)
    WRITE           reduce using rule 61 (expression -> expression = expression .)
    READLN          reduce using rule 61 (expression -> expression = expression .)
    ID              reduce using rule 61 (expression -> expression = expression .)
    END             reduce using rule 61 (expression -> expression = expression .)
    ELSE            reduce using rule 61 (expression -> expression = expression .)
    RBRACKET        reduce using rule 61 (expression -> expression = expression .)
    )               reduce using rule 61 (expression -> expression = expression .)
    ,               reduce using rule 61 (expression -> expression = expression .)
    TO              reduce using rule 61 (expression -> expression = expression .)
    DOWNTO          reduce using rule 61 (expression -> expression = expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! +               [ reduce using rule 61 (expression -> expression = expression .) ]
  ! -               [ reduce using rule 61 (expression -> expression = expression .) ]
  ! *               [ reduce using rule 61 (expression -> expression = expression .) ]
  ! /               [ reduce using rule 61 (expression -> expression = expression .) ]
  ! DIV             [ reduce using rule 61 (expression -> expression = expression .) ]
  ! MOD             [ reduce using rule 61 (expression -> expression = expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 122

    (62) expression -> expression < expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 62 (expression -> expression < expression .)
    AND             reduce using rule 62 (expression -> expression < expression .)
    OR              reduce using rule 62 (expression -> expression < expression .)
    =               reduce using rule 62 (expression -> expression < expression .)
    <               reduce using rule 62 (expression -> expression < expression .)
    >               reduce using rule 62 (expression -> expression < expression .)
    LE              reduce using rule 62 (expression -> expression < expression .)
    GE              reduce using rule 62 (expression -> expression < expression .)
    NE              reduce using rule 62 (expression -> expression < expression .)
    DO              reduce using rule 62 (expression -> expression < expression .)
    ;               reduce using rule 62 (expression -> expression < expression .)
    IF              reduce using rule 62 (expression -> expression < expression .)
    WHILE           reduce using rule 62 (expression -> expression < expression .)
    FOR             reduce using rule 62 (expression -> expression < expression .)
    BEGIN           reduce using rule 62 (expression -> expression < expression .)
    WRITELN         reduce using rule 62 (expression -> expression < expression .)
    WRITE           reduce using rule 62 (expression -> expression < expression .)
    READLN          reduce using rule 62 (expression -> expression < expression .)
    ID              reduce using rule 62 (expression -> expression < expression .)
    END             reduce using rule 62 (expression -> expression < expression .)
    ELSE            reduce using rule 62 (expression -> expression < expression .)
    RBRACKET        reduce using rule 62 (expression -> expression < expression .)
    )               reduce using rule 62 (expression -> expression < expression .)
    ,               reduce using rule 62 (expression -> expression < expression .)
    TO              reduce using rule 62 (expression -> expression < expression .)
    DOWNTO          reduce using rule 62 (expression -> expression < expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! +               [ reduce using rule 62 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 62 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 62 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 62 (expression -> expression < expression .) ]
  ! DIV             [ reduce using rule 62 (expression -> expression < expression .) ]
  ! MOD             [ reduce using rule 62 (expression -> expression < expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 123

    (63) expression -> expression > expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 63 (expression -> expression > expression .)
    AND             reduce using rule 63 (expression -> expression > expression .)
    OR              reduce using rule 63 (expression -> expression > expression .)
    =               reduce using rule 63 (expression -> expression > expression .)
    <               reduce using rule 63 (expression -> expression > expression .)
    >               reduce using rule 63 (expression -> expression > expression .)
    LE              reduce using rule 63 (expression -> expression > expression .)
    GE              reduce using rule 63 (expression -> expression > expression .)
    NE              reduce using rule 63 (expression -> expression > expression .)
    DO              reduce using rule 63 (expression -> expression > expression .)
    ;               reduce using rule 63 (expression -> expression > expression .)
    IF              reduce using rule 63 (expression -> expression > expression .)
    WHILE           reduce using rule 63 (expression -> expression > expression .)
    FOR             reduce using rule 63 (expression -> expression > expression .)
    BEGIN           reduce using rule 63 (expression -> expression > expression .)
    WRITELN         reduce using rule 63 (expression -> expression > expression .)
    WRITE           reduce using rule 63 (expression -> expression > expression .)
    READLN          reduce using rule 63 (expression -> expression > expression .)
    ID              reduce using rule 63 (expression -> expression > expression .)
    END             reduce using rule 63 (expression -> expression > expression .)
    ELSE            reduce using rule 63 (expression -> expression > expression .)
    RBRACKET        reduce using rule 63 (expression -> expression > expression .)
    )               reduce using rule 63 (expression -> expression > expression .)
    ,               reduce using rule 63 (expression -> expression > expression .)
    TO              reduce using rule 63 (expression -> expression > expression .)
    DOWNTO          reduce using rule 63 (expression -> expression > expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! +               [ reduce using rule 63 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 63 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 63 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 63 (expression -> expression > expression .) ]
  ! DIV             [ reduce using rule 63 (expression -> expression > expression .) ]
  ! MOD             [ reduce using rule 63 (expression -> expression > expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 124

    (64) expression -> expression LE expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 64 (expression -> expression LE expression .)
    AND             reduce using rule 64 (expression -> expression LE expression .)
    OR              reduce using rule 64 (expression -> expression LE expression .)
    =               reduce using rule 64 (expression -> expression LE expression .)
    <               reduce using rule 64 (expression -> expression LE expression .)
    >               reduce using rule 64 (expression -> expression LE expression .)
    LE              reduce using rule 64 (expression -> expression LE expression .)
    GE              reduce using rule 64 (expression -> expression LE expression .)
    NE              reduce using rule 64 (expression -> expression LE expression .)
    DO              reduce using rule 64 (expression -> expression LE expression .)
    ;               reduce using rule 64 (expression -> expression LE expression .)
    IF              reduce using rule 64 (expression -> expression LE expression .)
    WHILE           reduce using rule 64 (expression -> expression LE expression .)
    FOR             reduce using rule 64 (expression -> expression LE expression .)
    BEGIN           reduce using rule 64 (expression -> expression LE expression .)
    WRITELN         reduce using rule 64 (expression -> expression LE expression .)
    WRITE           reduce using rule 64 (expression -> expression LE expression .)
    READLN          reduce using rule 64 (expression -> expression LE expression .)
    ID              reduce using rule 64 (expression -> expression LE expression .)
    END             reduce using rule 64 (expression -> expression LE expression .)
    ELSE            reduce using rule 64 (expression -> expression LE expression .)
    RBRACKET        reduce using rule 64 (expression -> expression LE expression .)
    )               reduce using rule 64 (expression -> expression LE expression .)
    ,               reduce using rule 64 (expression -> expression LE expression .)
    TO              reduce using rule 64 (expression -> expression LE expression .)
    DOWNTO          reduce using rule 64 (expression -> expression LE expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! +               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! DIV             [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! MOD             [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 125

    (65) expression -> expression GE expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 65 (expression -> expression GE expression .)
    AND             reduce using rule 65 (expression -> expression GE expression .)
    OR              reduce using rule 65 (expression -> expression GE expression .)
    =               reduce using rule 65 (expression -> expression GE expression .)
    <               reduce using rule 65 (expression -> expression GE expression .)
    >               reduce using rule 65 (expression -> expression GE expression .)
    LE              reduce using rule 65 (expression -> expression GE expression .)
    GE              reduce using rule 65 (expression -> expression GE expression .)
    NE              reduce using rule 65 (expression -> expression GE expression .)
    DO              reduce using rule 65 (expression -> expression GE expression .)
    ;               reduce using rule 65 (expression -> expression GE expression .)
    IF              reduce using rule 65 (expression -> expression GE expression .)
    WHILE           reduce using rule 65 (expression -> expression GE expression .)
    FOR             reduce using rule 65 (expression -> expression GE expression .)
    BEGIN           reduce using rule 65 (expression -> expression GE expression .)
    WRITELN         reduce using rule 65 (expression -> expression GE expression .)
    WRITE           reduce using rule 65 (expression -> expression GE expression .)
    READLN          reduce using rule 65 (expression -> expression GE expression .)
    ID              reduce using rule 65 (expression -> expression GE expression .)
    END             reduce using rule 65 (expression -> expression GE expression .)
    ELSE            reduce using rule 65 (expression -> expression GE expression .)
    RBRACKET        reduce using rule 65 (expression -> expression GE expression .)
    )               reduce using rule 65 (expression -> expression GE expression .)
    ,               reduce using rule 65 (expression -> expression GE expression .)
    TO              reduce using rule 65 (expression -> expression GE expression .)
    DOWNTO          reduce using rule 65 (expression -> expression GE expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! +               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! DIV             [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! MOD             [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 126

    (66) expression -> expression NE expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    THEN            reduce using rule 66 (expression -> expression NE expression .)
    AND             reduce using rule 66 (expression -> expression NE expression .)
    OR              reduce using rule 66 (expression -> expression NE expression .)
    =               reduce using rule 66 (expression -> expression NE expression .)
    <               reduce using rule 66 (expression -> expression NE expression .)
    >               reduce using rule 66 (expression -> expression NE expression .)
    LE              reduce using rule 66 (expression -> expression NE expression .)
    GE              reduce using rule 66 (expression -> expression NE expression .)
    NE              reduce using rule 66 (expression -> expression NE expression .)
    DO              reduce using rule 66 (expression -> expression NE expression .)
    ;               reduce using rule 66 (expression -> expression NE expression .)
    IF              reduce using rule 66 (expression -> expression NE expression .)
    WHILE           reduce using rule 66 (expression -> expression NE expression .)
    FOR             reduce using rule 66 (expression -> expression NE expression .)
    BEGIN           reduce using rule 66 (expression -> expression NE expression .)
    WRITELN         reduce using rule 66 (expression -> expression NE expression .)
    WRITE           reduce using rule 66 (expression -> expression NE expression .)
    READLN          reduce using rule 66 (expression -> expression NE expression .)
    ID              reduce using rule 66 (expression -> expression NE expression .)
    END             reduce using rule 66 (expression -> expression NE expression .)
    ELSE            reduce using rule 66 (expression -> expression NE expression .)
    RBRACKET        reduce using rule 66 (expression -> expression NE expression .)
    )               reduce using rule 66 (expression -> expression NE expression .)
    ,               reduce using rule 66 (expression -> expression NE expression .)
    TO              reduce using rule 66 (expression -> expression NE expression .)
    DOWNTO          reduce using rule 66 (expression -> expression NE expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87

  ! +               [ reduce using rule 66 (expression -> expression NE expression .) ]
  ! -               [ reduce using rule 66 (expression -> expression NE expression .) ]
  ! *               [ reduce using rule 66 (expression -> expression NE expression .) ]
  ! /               [ reduce using rule 66 (expression -> expression NE expression .) ]
  ! DIV             [ reduce using rule 66 (expression -> expression NE expression .) ]
  ! MOD             [ reduce using rule 66 (expression -> expression NE expression .) ]
  ! AND             [ shift and go to state 88 ]
  ! OR              [ shift and go to state 89 ]
  ! =               [ shift and go to state 90 ]
  ! <               [ shift and go to state 91 ]
  ! >               [ shift and go to state 92 ]
  ! LE              [ shift and go to state 93 ]
  ! GE              [ shift and go to state 94 ]
  ! NE              [ shift and go to state 95 ]


state 127

    (68) expression -> ( expression ) .

    THEN            reduce using rule 68 (expression -> ( expression ) .)
    +               reduce using rule 68 (expression -> ( expression ) .)
    -               reduce using rule 68 (expression -> ( expression ) .)
    *               reduce using rule 68 (expression -> ( expression ) .)
    /               reduce using rule 68 (expression -> ( expression ) .)
    DIV             reduce using rule 68 (expression -> ( expression ) .)
    MOD             reduce using rule 68 (expression -> ( expression ) .)
    AND             reduce using rule 68 (expression -> ( expression ) .)
    OR              reduce using rule 68 (expression -> ( expression ) .)
    =               reduce using rule 68 (expression -> ( expression ) .)
    <               reduce using rule 68 (expression -> ( expression ) .)
    >               reduce using rule 68 (expression -> ( expression ) .)
    LE              reduce using rule 68 (expression -> ( expression ) .)
    GE              reduce using rule 68 (expression -> ( expression ) .)
    NE              reduce using rule 68 (expression -> ( expression ) .)
    DO              reduce using rule 68 (expression -> ( expression ) .)
    ;               reduce using rule 68 (expression -> ( expression ) .)
    IF              reduce using rule 68 (expression -> ( expression ) .)
    WHILE           reduce using rule 68 (expression -> ( expression ) .)
    FOR             reduce using rule 68 (expression -> ( expression ) .)
    BEGIN           reduce using rule 68 (expression -> ( expression ) .)
    WRITELN         reduce using rule 68 (expression -> ( expression ) .)
    WRITE           reduce using rule 68 (expression -> ( expression ) .)
    READLN          reduce using rule 68 (expression -> ( expression ) .)
    ID              reduce using rule 68 (expression -> ( expression ) .)
    END             reduce using rule 68 (expression -> ( expression ) .)
    ELSE            reduce using rule 68 (expression -> ( expression ) .)
    RBRACKET        reduce using rule 68 (expression -> ( expression ) .)
    )               reduce using rule 68 (expression -> ( expression ) .)
    ,               reduce using rule 68 (expression -> ( expression ) .)
    TO              reduce using rule 68 (expression -> ( expression ) .)
    DOWNTO          reduce using rule 68 (expression -> ( expression ) .)


state 128

    (72) expression -> ID LBRACKET expression . RBRACKET
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    RBRACKET        shift and go to state 143
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 129

    (77) expression -> ID ( expression_list_opt . )

    )               shift and go to state 144


state 130

    (78) expression_list_opt -> expression_list .
    (76) expression_list -> expression_list . , expression

    )               reduce using rule 78 (expression_list_opt -> expression_list .)
    ,               shift and go to state 135


state 131

    (79) expression_list_opt -> empty .

    )               reduce using rule 79 (expression_list_opt -> empty .)


state 132

    (45) while_loop -> WHILE expression DO statement .

    ;               reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    IF              reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    WHILE           reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    FOR             reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    BEGIN           reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    WRITELN         reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    WRITE           reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    READLN          reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    ID              reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    END             reduce using rule 45 (while_loop -> WHILE expression DO statement .)
    ELSE            reduce using rule 45 (while_loop -> WHILE expression DO statement .)


state 133

    (46) for_loop -> FOR ID ASSIGN expression . TO expression DO statement
    (47) for_loop -> FOR ID ASSIGN expression . DOWNTO expression DO statement
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    TO              shift and go to state 145
    DOWNTO          shift and go to state 146
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 134

    (50) writeln -> WRITELN ( expression_list ) .

    ;               reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    IF              reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    WHILE           reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    FOR             reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    BEGIN           reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    WRITELN         reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    WRITE           reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    READLN          reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    ID              reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    END             reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)
    ELSE            reduce using rule 50 (writeln -> WRITELN ( expression_list ) .)


state 135

    (76) expression_list -> expression_list , . expression
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 147
    variable                       shift and go to state 60

state 136

    (51) write -> WRITE ( expression_list ) .

    ;               reduce using rule 51 (write -> WRITE ( expression_list ) .)
    IF              reduce using rule 51 (write -> WRITE ( expression_list ) .)
    WHILE           reduce using rule 51 (write -> WRITE ( expression_list ) .)
    FOR             reduce using rule 51 (write -> WRITE ( expression_list ) .)
    BEGIN           reduce using rule 51 (write -> WRITE ( expression_list ) .)
    WRITELN         reduce using rule 51 (write -> WRITE ( expression_list ) .)
    WRITE           reduce using rule 51 (write -> WRITE ( expression_list ) .)
    READLN          reduce using rule 51 (write -> WRITE ( expression_list ) .)
    ID              reduce using rule 51 (write -> WRITE ( expression_list ) .)
    END             reduce using rule 51 (write -> WRITE ( expression_list ) .)
    ELSE            reduce using rule 51 (write -> WRITE ( expression_list ) .)


state 137

    (52) readln -> READLN ( expression_list ) .

    ;               reduce using rule 52 (readln -> READLN ( expression_list ) .)
    IF              reduce using rule 52 (readln -> READLN ( expression_list ) .)
    WHILE           reduce using rule 52 (readln -> READLN ( expression_list ) .)
    FOR             reduce using rule 52 (readln -> READLN ( expression_list ) .)
    BEGIN           reduce using rule 52 (readln -> READLN ( expression_list ) .)
    WRITELN         reduce using rule 52 (readln -> READLN ( expression_list ) .)
    WRITE           reduce using rule 52 (readln -> READLN ( expression_list ) .)
    READLN          reduce using rule 52 (readln -> READLN ( expression_list ) .)
    ID              reduce using rule 52 (readln -> READLN ( expression_list ) .)
    END             reduce using rule 52 (readln -> READLN ( expression_list ) .)
    ELSE            reduce using rule 52 (readln -> READLN ( expression_list ) .)


state 138

    (26) type -> ARRAY LBRACKET NUMBER . DOTDOT NUMBER RBRACKET OF type

    DOTDOT          shift and go to state 148


state 139

    (19) param -> ID : type .

    ,               reduce using rule 19 (param -> ID : type .)
    )               reduce using rule 19 (param -> ID : type .)


state 140

    (12) function_declaration -> FUNCTION ID ( param_list_opt ) : . type ; function_block ;
    (23) type -> . INTEGER
    (24) type -> . BOOLEAN
    (25) type -> . STRING_TYPE
    (26) type -> . ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    INTEGER         shift and go to state 67
    BOOLEAN         shift and go to state 68
    STRING_TYPE     shift and go to state 69
    ARRAY           shift and go to state 70

    type                           shift and go to state 149

state 141

    (17) param_list -> param_list , param .

    ,               reduce using rule 17 (param_list -> param_list , param .)
    )               reduce using rule 17 (param_list -> param_list , param .)


state 142

    (41) if_statement -> IF expression THEN statement ELSE . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ELSE            reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    END             reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    statement                      shift and go to state 150
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 143

    (72) expression -> ID LBRACKET expression RBRACKET .

    THEN            reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    +               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    -               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    *               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    /               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    DIV             reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    MOD             reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    AND             reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    OR              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    =               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    <               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    >               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    LE              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    GE              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    NE              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    DO              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    ;               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    IF              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    WHILE           reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    FOR             reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    BEGIN           reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    WRITELN         reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    WRITE           reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    READLN          reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    ID              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    END             reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    ELSE            reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    )               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    ,               reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    TO              reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)
    DOWNTO          reduce using rule 72 (expression -> ID LBRACKET expression RBRACKET .)


state 144

    (77) expression -> ID ( expression_list_opt ) .

    THEN            reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    +               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    -               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    *               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    /               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    DIV             reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    MOD             reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    AND             reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    OR              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    =               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    <               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    >               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    LE              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    GE              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    NE              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    DO              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    ;               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    IF              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    WHILE           reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    FOR             reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    BEGIN           reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    WRITELN         reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    WRITE           reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    READLN          reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    ID              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    END             reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    ELSE            reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    RBRACKET        reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    )               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    ,               reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    TO              reduce using rule 77 (expression -> ID ( expression_list_opt ) .)
    DOWNTO          reduce using rule 77 (expression -> ID ( expression_list_opt ) .)


state 145

    (46) for_loop -> FOR ID ASSIGN expression TO . expression DO statement
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 151
    variable                       shift and go to state 60

state 146

    (47) for_loop -> FOR ID ASSIGN expression DOWNTO . expression DO statement
    (49) expression -> . STRING
    (53) expression -> . expression + expression
    (54) expression -> . expression - expression
    (55) expression -> . expression * expression
    (56) expression -> . expression / expression
    (57) expression -> . expression DIV expression
    (58) expression -> . expression MOD expression
    (59) expression -> . expression AND expression
    (60) expression -> . expression OR expression
    (61) expression -> . expression = expression
    (62) expression -> . expression < expression
    (63) expression -> . expression > expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . expression NE expression
    (67) expression -> . NOT expression
    (68) expression -> . ( expression )
    (69) expression -> . NUMBER
    (70) expression -> . TRUE
    (71) expression -> . FALSE
    (72) expression -> . ID LBRACKET expression RBRACKET
    (73) expression -> . variable
    (74) expression -> . ID
    (77) expression -> . ID ( expression_list_opt )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

    STRING          shift and go to state 53
    NOT             shift and go to state 54
    (               shift and go to state 55
    NUMBER          shift and go to state 56
    TRUE            shift and go to state 57
    FALSE           shift and go to state 58
    ID              shift and go to state 59

    expression                     shift and go to state 152
    variable                       shift and go to state 60

state 147

    (76) expression_list -> expression_list , expression .
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    )               reduce using rule 76 (expression_list -> expression_list , expression .)
    ,               reduce using rule 76 (expression_list -> expression_list , expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 148

    (26) type -> ARRAY LBRACKET NUMBER DOTDOT . NUMBER RBRACKET OF type

    NUMBER          shift and go to state 153


state 149

    (12) function_declaration -> FUNCTION ID ( param_list_opt ) : type . ; function_block ;

    ;               shift and go to state 154


state 150

    (41) if_statement -> IF expression THEN statement ELSE statement .

    ;               reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    IF              reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    WHILE           reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    FOR             reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    BEGIN           reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    WRITELN         reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    WRITE           reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    READLN          reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    ID              reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    END             reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)
    ELSE            reduce using rule 41 (if_statement -> IF expression THEN statement ELSE statement .)


state 151

    (46) for_loop -> FOR ID ASSIGN expression TO expression . DO statement
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    DO              shift and go to state 155
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 152

    (47) for_loop -> FOR ID ASSIGN expression DOWNTO expression . DO statement
    (53) expression -> expression . + expression
    (54) expression -> expression . - expression
    (55) expression -> expression . * expression
    (56) expression -> expression . / expression
    (57) expression -> expression . DIV expression
    (58) expression -> expression . MOD expression
    (59) expression -> expression . AND expression
    (60) expression -> expression . OR expression
    (61) expression -> expression . = expression
    (62) expression -> expression . < expression
    (63) expression -> expression . > expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression
    (66) expression -> expression . NE expression

    DO              shift and go to state 156
    +               shift and go to state 82
    -               shift and go to state 83
    *               shift and go to state 84
    /               shift and go to state 85
    DIV             shift and go to state 86
    MOD             shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89
    =               shift and go to state 90
    <               shift and go to state 91
    >               shift and go to state 92
    LE              shift and go to state 93
    GE              shift and go to state 94
    NE              shift and go to state 95


state 153

    (26) type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER . RBRACKET OF type

    RBRACKET        shift and go to state 157


state 154

    (12) function_declaration -> FUNCTION ID ( param_list_opt ) : type ; . function_block ;
    (13) function_block -> . VAR var_declarations BEGIN optional_statements END
    (14) function_block -> . BEGIN optional_statements END

    VAR             shift and go to state 159
    BEGIN           shift and go to state 160

    function_block                 shift and go to state 158

state 155

    (46) for_loop -> FOR ID ASSIGN expression TO expression DO . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ELSE            reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    END             reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    statement                      shift and go to state 161
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 156

    (47) for_loop -> FOR ID ASSIGN expression DOWNTO expression DO . statement
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (80) empty -> .
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ELSE            reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    END             reduce using rule 80 (empty -> .)
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    statement                      shift and go to state 162
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    empty                          shift and go to state 46
    variable                       shift and go to state 33

state 157

    (26) type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET . OF type

    OF              shift and go to state 163


state 158

    (12) function_declaration -> FUNCTION ID ( param_list_opt ) : type ; function_block . ;

    ;               shift and go to state 164


state 159

    (13) function_block -> VAR . var_declarations BEGIN optional_statements END
    (10) var_declarations -> . var_declarations var_declaration
    (11) var_declarations -> . var_declaration
    (22) var_declaration -> . id_list : type ;
    (20) id_list -> . ID
    (21) id_list -> . id_list , ID

    ID              shift and go to state 18

    var_declarations               shift and go to state 165
    var_declaration                shift and go to state 16
    id_list                        shift and go to state 17

state 160

    (14) function_block -> BEGIN . optional_statements END
    (3) optional_statements -> . statements
    (4) optional_statements -> . empty
    (27) statements -> . statements statement ;
    (28) statements -> . statements statement
    (29) statements -> . statement ;
    (30) statements -> . statement
    (80) empty -> .
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    END             reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    optional_statements            shift and go to state 166
    statements                     shift and go to state 22
    empty                          shift and go to state 23
    statement                      shift and go to state 24
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    variable                       shift and go to state 33

state 161

    (46) for_loop -> FOR ID ASSIGN expression TO expression DO statement .

    ;               reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    IF              reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    WHILE           reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    FOR             reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    BEGIN           reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    WRITELN         reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    WRITE           reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    READLN          reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    ID              reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    END             reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)
    ELSE            reduce using rule 46 (for_loop -> FOR ID ASSIGN expression TO expression DO statement .)


state 162

    (47) for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .

    ;               reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    IF              reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    WHILE           reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    FOR             reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    BEGIN           reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    WRITELN         reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    WRITE           reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    READLN          reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    ID              reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    END             reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)
    ELSE            reduce using rule 47 (for_loop -> FOR ID ASSIGN expression DOWNTO expression DO statement .)


state 163

    (26) type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF . type
    (23) type -> . INTEGER
    (24) type -> . BOOLEAN
    (25) type -> . STRING_TYPE
    (26) type -> . ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type

    INTEGER         shift and go to state 67
    BOOLEAN         shift and go to state 68
    STRING_TYPE     shift and go to state 69
    ARRAY           shift and go to state 70

    type                           shift and go to state 167

state 164

    (12) function_declaration -> FUNCTION ID ( param_list_opt ) : type ; function_block ; .

    BEGIN           reduce using rule 12 (function_declaration -> FUNCTION ID ( param_list_opt ) : type ; function_block ; .)
    VAR             reduce using rule 12 (function_declaration -> FUNCTION ID ( param_list_opt ) : type ; function_block ; .)
    FUNCTION        reduce using rule 12 (function_declaration -> FUNCTION ID ( param_list_opt ) : type ; function_block ; .)


state 165

    (13) function_block -> VAR var_declarations . BEGIN optional_statements END
    (10) var_declarations -> var_declarations . var_declaration
    (22) var_declaration -> . id_list : type ;
    (20) id_list -> . ID
    (21) id_list -> . id_list , ID

    BEGIN           shift and go to state 168
    ID              shift and go to state 18

    var_declaration                shift and go to state 41
    id_list                        shift and go to state 17

state 166

    (14) function_block -> BEGIN optional_statements . END

    END             shift and go to state 169


state 167

    (26) type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type .

    ;               reduce using rule 26 (type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type .)
    ,               reduce using rule 26 (type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type .)
    )               reduce using rule 26 (type -> ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF type .)


state 168

    (13) function_block -> VAR var_declarations BEGIN . optional_statements END
    (3) optional_statements -> . statements
    (4) optional_statements -> . empty
    (27) statements -> . statements statement ;
    (28) statements -> . statements statement
    (29) statements -> . statement ;
    (30) statements -> . statement
    (80) empty -> .
    (31) statement -> . assignment
    (32) statement -> . if_statement
    (33) statement -> . while_loop
    (34) statement -> . for_loop
    (35) statement -> . compound_statement
    (36) statement -> . writeln
    (37) statement -> . write
    (38) statement -> . readln
    (39) statement -> . empty
    (40) assignment -> . variable ASSIGN expression
    (41) if_statement -> . IF expression THEN statement ELSE statement
    (42) if_statement -> . IF expression THEN statement
    (45) while_loop -> . WHILE expression DO statement
    (46) for_loop -> . FOR ID ASSIGN expression TO expression DO statement
    (47) for_loop -> . FOR ID ASSIGN expression DOWNTO expression DO statement
    (48) compound_statement -> . BEGIN statements END
    (50) writeln -> . WRITELN ( expression_list )
    (51) write -> . WRITE ( expression_list )
    (52) readln -> . READLN ( expression_list )
    (43) variable -> . ID
    (44) variable -> . variable LBRACKET expression RBRACKET

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for WRITELN resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for READLN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    END             reduce using rule 80 (empty -> .)
    ;               reduce using rule 80 (empty -> .)
    IF              shift and go to state 34
    WHILE           shift and go to state 35
    FOR             shift and go to state 36
    BEGIN           shift and go to state 20
    WRITELN         shift and go to state 38
    WRITE           shift and go to state 39
    READLN          shift and go to state 40
    ID              shift and go to state 37

  ! IF              [ reduce using rule 80 (empty -> .) ]
  ! WHILE           [ reduce using rule 80 (empty -> .) ]
  ! FOR             [ reduce using rule 80 (empty -> .) ]
  ! BEGIN           [ reduce using rule 80 (empty -> .) ]
  ! WRITELN         [ reduce using rule 80 (empty -> .) ]
  ! WRITE           [ reduce using rule 80 (empty -> .) ]
  ! READLN          [ reduce using rule 80 (empty -> .) ]
  ! ID              [ reduce using rule 80 (empty -> .) ]

    optional_statements            shift and go to state 170
    statements                     shift and go to state 22
    empty                          shift and go to state 23
    statement                      shift and go to state 24
    assignment                     shift and go to state 25
    if_statement                   shift and go to state 26
    while_loop                     shift and go to state 27
    for_loop                       shift and go to state 28
    compound_statement             shift and go to state 29
    writeln                        shift and go to state 30
    write                          shift and go to state 31
    readln                         shift and go to state 32
    variable                       shift and go to state 33

state 169

    (14) function_block -> BEGIN optional_statements END .

    ;               reduce using rule 14 (function_block -> BEGIN optional_statements END .)


state 170

    (13) function_block -> VAR var_declarations BEGIN optional_statements . END

    END             shift and go to state 171


state 171

    (13) function_block -> VAR var_declarations BEGIN optional_statements END .

    ;               reduce using rule 13 (function_block -> VAR var_declarations BEGIN optional_statements END .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 4 resolved as shift
WARNING: shift/reduce conflict for FUNCTION in state 4 resolved as shift
WARNING: shift/reduce conflict for IF in state 13 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 13 resolved as shift
WARNING: shift/reduce conflict for FOR in state 13 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 13 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 13 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 13 resolved as shift
WARNING: shift/reduce conflict for READLN in state 13 resolved as shift
WARNING: shift/reduce conflict for ID in state 13 resolved as shift
WARNING: shift/reduce conflict for IF in state 20 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 20 resolved as shift
WARNING: shift/reduce conflict for FOR in state 20 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 20 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 20 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 20 resolved as shift
WARNING: shift/reduce conflict for READLN in state 20 resolved as shift
WARNING: shift/reduce conflict for ID in state 20 resolved as shift
WARNING: shift/reduce conflict for IF in state 22 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 22 resolved as shift
WARNING: shift/reduce conflict for FOR in state 22 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 22 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 22 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 22 resolved as shift
WARNING: shift/reduce conflict for READLN in state 22 resolved as shift
WARNING: shift/reduce conflict for ID in state 22 resolved as shift
WARNING: shift/reduce conflict for ; in state 24 resolved as shift
WARNING: shift/reduce conflict for END in state 45 resolved as shift
WARNING: shift/reduce conflict for IF in state 45 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 45 resolved as shift
WARNING: shift/reduce conflict for FOR in state 45 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 45 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 45 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 45 resolved as shift
WARNING: shift/reduce conflict for READLN in state 45 resolved as shift
WARNING: shift/reduce conflict for ID in state 45 resolved as shift
WARNING: shift/reduce conflict for ; in state 48 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 59 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 81 resolved as shift
WARNING: shift/reduce conflict for FOR in state 81 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 81 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 81 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 81 resolved as shift
WARNING: shift/reduce conflict for READLN in state 81 resolved as shift
WARNING: shift/reduce conflict for ID in state 81 resolved as shift
WARNING: shift/reduce conflict for IF in state 100 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 100 resolved as shift
WARNING: shift/reduce conflict for FOR in state 100 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 100 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 100 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 100 resolved as shift
WARNING: shift/reduce conflict for READLN in state 100 resolved as shift
WARNING: shift/reduce conflict for ID in state 100 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 112 resolved as shift
WARNING: shift/reduce conflict for IF in state 142 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 142 resolved as shift
WARNING: shift/reduce conflict for FOR in state 142 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 142 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 142 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 142 resolved as shift
WARNING: shift/reduce conflict for READLN in state 142 resolved as shift
WARNING: shift/reduce conflict for ID in state 142 resolved as shift
WARNING: shift/reduce conflict for IF in state 155 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 155 resolved as shift
WARNING: shift/reduce conflict for FOR in state 155 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 155 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 155 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 155 resolved as shift
WARNING: shift/reduce conflict for READLN in state 155 resolved as shift
WARNING: shift/reduce conflict for ID in state 155 resolved as shift
WARNING: shift/reduce conflict for IF in state 156 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 156 resolved as shift
WARNING: shift/reduce conflict for FOR in state 156 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 156 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 156 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 156 resolved as shift
WARNING: shift/reduce conflict for READLN in state 156 resolved as shift
WARNING: shift/reduce conflict for ID in state 156 resolved as shift
WARNING: shift/reduce conflict for IF in state 160 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 160 resolved as shift
WARNING: shift/reduce conflict for FOR in state 160 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 160 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 160 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 160 resolved as shift
WARNING: shift/reduce conflict for READLN in state 160 resolved as shift
WARNING: shift/reduce conflict for ID in state 160 resolved as shift
WARNING: shift/reduce conflict for IF in state 168 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 168 resolved as shift
WARNING: shift/reduce conflict for FOR in state 168 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 168 resolved as shift
WARNING: shift/reduce conflict for WRITELN in state 168 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 168 resolved as shift
WARNING: shift/reduce conflict for READLN in state 168 resolved as shift
WARNING: shift/reduce conflict for ID in state 168 resolved as shift
WARNING: reduce/reduce conflict in state 22 resolved using rule (optional_statements -> statements)
WARNING: rejected rule (empty -> <empty>) in state 22
WARNING: reduce/reduce conflict in state 23 resolved using rule (optional_statements -> empty)
WARNING: rejected rule (statement -> empty) in state 23
WARNING: reduce/reduce conflict in state 59 resolved using rule (variable -> ID)
WARNING: rejected rule (expression -> ID) in state 59
WARNING: Rule (expression -> ID) is never reduced
